export const events_compiledmap={
  "WP02": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WP03": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WF01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-vk2f6a\", \".main.svelte-vk2f6a{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-vk2f6a{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-vk2f6a{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-vk2f6a{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}\");\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-vk2f6a\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-vk2f6a\");\n      attr(p, \"class\", \"svelte-vk2f6a\");\n      attr(div1, \"class\", \"main svelte-vk2f6a\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://picsum.photos/200/300\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(() => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n    }\n    if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n      fetch(\"https://petri-back.vercel.app/internal/image/\", {\n        method: \"POST\",\n        headers: { \"Content-type\": \"application/json\" },\n        credentials: \"include\",\n        mode: \"cors\",\n        body: JSON.stringify({ name, \"password\": \"joPcyq-kipwyc-2jygva\" })\n      }).then((res) => res.json()).then((res) => {\n        const imageURL = `data:image/png;base64,${res.image}`;\n        $$invalidate(2, url = `${imageURL}`);\n      });\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-vydx3c\", \".buttons.svelte-vydx3c.svelte-vydx3c{margin-top:2rem;margin-bottom:2rem}.buttons.svelte-vydx3c>button.svelte-vydx3c{margin-left:0.75em;margin-right:0.75em}button.svelte-vydx3c.svelte-vydx3c{border:none;background-color:transparent}.a-unset.svelte-vydx3c.svelte-vydx3c{text-decoration:none;color:white}.register.svelte-vydx3c.svelte-vydx3c{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-vydx3c.svelte-vydx3c:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-vydx3c.svelte-vydx3c{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-vydx3c.svelte-vydx3c{margin-bottom:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-vydx3c\");\n      attr(div, \"class\", \"buttons svelte-vydx3c\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Voicestra\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({ props: { name: \"Human\", phone: \"1234\" } });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TF01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-vk2f6a\", \".main.svelte-vk2f6a{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-vk2f6a{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-vk2f6a{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-vk2f6a{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}\");\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-vk2f6a\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-vk2f6a\");\n      attr(p, \"class\", \"svelte-vk2f6a\");\n      attr(div1, \"class\", \"main svelte-vk2f6a\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://picsum.photos/200/300\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(() => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n    }\n    if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n      fetch(\"https://petri-back.vercel.app/internal/image/\", {\n        method: \"POST\",\n        headers: { \"Content-type\": \"application/json\" },\n        credentials: \"include\",\n        mode: \"cors\",\n        body: JSON.stringify({ name, \"password\": \"joPcyq-kipwyc-2jygva\" })\n      }).then((res) => res.json()).then((res) => {\n        const imageURL = `data:image/png;base64,${res.image}`;\n        $$invalidate(2, url = `${imageURL}`);\n      });\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-vydx3c\", \".buttons.svelte-vydx3c.svelte-vydx3c{margin-top:2rem;margin-bottom:2rem}.buttons.svelte-vydx3c>button.svelte-vydx3c{margin-left:0.75em;margin-right:0.75em}button.svelte-vydx3c.svelte-vydx3c{border:none;background-color:transparent}.a-unset.svelte-vydx3c.svelte-vydx3c{text-decoration:none;color:white}.register.svelte-vydx3c.svelte-vydx3c{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-vydx3c.svelte-vydx3c:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-vydx3c.svelte-vydx3c{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-vydx3c.svelte-vydx3c{margin-bottom:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-vydx3c\");\n      attr(div, \"class\", \"buttons svelte-vydx3c\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Anything Here will be center aligned\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"Anything Here will be enclosed inside a box\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"You can use Components inside components like this.\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h10;\n  let t1;\n  let p0;\n  let t5;\n  let h11;\n  let t7;\n  let p1;\n  let t11;\n  let centersection;\n  let t12;\n  let h12;\n  let t14;\n  let p2;\n  let t18;\n  let box0;\n  let t19;\n  let h13;\n  let t21;\n  let box1;\n  let t22;\n  let h14;\n  let t24;\n  let p3;\n  let t28;\n  let flexsection;\n  let t29;\n  let h15;\n  let t31;\n  let p4;\n  let current;\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  box0 = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  box1 = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.innerHTML = `<code>&lt;Section&gt;</code>`;\n      t1 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `The <code>&lt;Section&gt;</code> component is a general-purpose wrapper for grouping content.`;\n      t5 = space();\n      h11 = element(\"h1\");\n      h11.innerHTML = `<code>&lt;CenterSection&gt;</code>`;\n      t7 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `The <code>&lt;CenterSection&gt;</code> component centers all its child content.`;\n      t11 = space();\n      create_component(centersection.$$.fragment);\n      t12 = space();\n      h12 = element(\"h1\");\n      h12.innerHTML = `<code>&lt;Box&gt;</code>`;\n      t14 = space();\n      p2 = element(\"p\");\n      p2.innerHTML = `The <code>&lt;Box&gt;</code> component encloses its child content within a styled container.`;\n      t18 = space();\n      create_component(box0.$$.fragment);\n      t19 = space();\n      h13 = element(\"h1\");\n      h13.innerHTML = `<code>Components Inside Components</code>`;\n      t21 = space();\n      create_component(box1.$$.fragment);\n      t22 = space();\n      h14 = element(\"h1\");\n      h14.innerHTML = `<code>&lt;FlexSection&gt;</code>`;\n      t24 = space();\n      p3 = element(\"p\");\n      p3.innerHTML = `The <code>&lt;FlexSection&gt;</code> component is designed for flexible layouts.`;\n      t28 = space();\n      create_component(flexsection.$$.fragment);\n      t29 = space();\n      h15 = element(\"h1\");\n      h15.textContent = \"Tutorial\";\n      t31 = space();\n      p4 = element(\"p\");\n      p4.textContent = \"Please go through the given tutorial_event.\";\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h11, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t11, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t12, anchor);\n      insert(target, h12, anchor);\n      insert(target, t14, anchor);\n      insert(target, p2, anchor);\n      insert(target, t18, anchor);\n      mount_component(box0, target, anchor);\n      insert(target, t19, anchor);\n      insert(target, h13, anchor);\n      insert(target, t21, anchor);\n      mount_component(box1, target, anchor);\n      insert(target, t22, anchor);\n      insert(target, h14, anchor);\n      insert(target, t24, anchor);\n      insert(target, p3, anchor);\n      insert(target, t28, anchor);\n      mount_component(flexsection, target, anchor);\n      insert(target, t29, anchor);\n      insert(target, h15, anchor);\n      insert(target, t31, anchor);\n      insert(target, p4, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const box0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box0.$set(box0_changes);\n      const box1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box1.$set(box1_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(centersection.$$.fragment, local);\n      transition_in(box0.$$.fragment, local);\n      transition_in(box1.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(centersection.$$.fragment, local);\n      transition_out(box0.$$.fragment, local);\n      transition_out(box1.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(p0);\n        detach(t5);\n        detach(h11);\n        detach(t7);\n        detach(p1);\n        detach(t11);\n        detach(t12);\n        detach(h12);\n        detach(t14);\n        detach(p2);\n        detach(t18);\n        detach(t19);\n        detach(h13);\n        detach(t21);\n        detach(t22);\n        detach(h14);\n        detach(t24);\n        detach(p3);\n        detach(t28);\n        detach(t29);\n        detach(h15);\n        detach(t31);\n        detach(p4);\n      }\n      destroy_component(centersection, detaching);\n      destroy_component(box0, detaching);\n      destroy_component(box1, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let h10;\n  let t1;\n  let p0;\n  let t3;\n  let h2;\n  let t5;\n  let h3;\n  let t7;\n  let p1;\n  let t9;\n  let ul;\n  let t11;\n  let p2;\n  let t13;\n  let ol;\n  let t15;\n  let p3;\n  let t17;\n  let h11;\n  let t19;\n  let section;\n  let t20;\n  let br0;\n  let t21;\n  let br1;\n  let t22;\n  let p4;\n  let t26;\n  let p5;\n  let t29;\n  let person;\n  let t30;\n  let p6;\n  let t32;\n  let p7;\n  let t34;\n  let p8;\n  let current;\n  section = new Section_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  person = new Person_default({ props: { name: \"Human\", phone: \"1234\" } });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Svelte Components Tutorial\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"This guide demonstrates the usage of custom Svelte components for structuring and styling content effectively. The following examples illustrate how to use each component.\";\n      t3 = space();\n      h2 = element(\"h2\");\n      h2.textContent = \"Basic HTML Usage\";\n      t5 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Example 1: Unordered List\";\n      t7 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"To create an unordered list:\";\n      t9 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Hello</li>`;\n      t11 = space();\n      p2 = element(\"p\");\n      p2.textContent = \"OR\";\n      t13 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>Hello</li>`;\n      t15 = space();\n      p3 = element(\"p\");\n      p3.textContent = \"You can use\\nany html tags here even styles if you want\";\n      t17 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Component Overview\";\n      t19 = space();\n      create_component(section.$$.fragment);\n      t20 = space();\n      br0 = element(\"br\");\n      t21 = space();\n      br1 = element(\"br\");\n      t22 = space();\n      p4 = element(\"p\");\n      p4.innerHTML = `In the <code>name</code> field, please exactly use the same name added to the above organizers sections.`;\n      t26 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `Example: Here I have given name: \\u2018Human\\u2019 in above organizer 0:\nHence Here I use the same name i.e. \\u201CHuman\\u201D to declare <code>&lt;Person /&gt;</code>`;\n      t29 = space();\n      create_component(person.$$.fragment);\n      t30 = space();\n      p6 = element(\"p\");\n      p6.textContent = \"NOTE: Also any updates/addititon to this website will not concurrently update the main petrichor website.\\nThe final push will be done from our side.\";\n      t32 = space();\n      p7 = element(\"p\");\n      p7.textContent = \"When you will press AddEvent on previous page you will get a template markdown.\";\n      t34 = space();\n      p8 = element(\"p\");\n      p8.textContent = \"Feel free to add more things or just edit the details you need to display.\";\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, h2, anchor);\n      insert(target, t5, anchor);\n      insert(target, h3, anchor);\n      insert(target, t7, anchor);\n      insert(target, p1, anchor);\n      insert(target, t9, anchor);\n      insert(target, ul, anchor);\n      insert(target, t11, anchor);\n      insert(target, p2, anchor);\n      insert(target, t13, anchor);\n      insert(target, ol, anchor);\n      insert(target, t15, anchor);\n      insert(target, p3, anchor);\n      insert(target, t17, anchor);\n      insert(target, h11, anchor);\n      insert(target, t19, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t20, anchor);\n      insert(target, br0, anchor);\n      insert(target, t21, anchor);\n      insert(target, br1, anchor);\n      insert(target, t22, anchor);\n      insert(target, p4, anchor);\n      insert(target, t26, anchor);\n      insert(target, p5, anchor);\n      insert(target, t29, anchor);\n      mount_component(person, target, anchor);\n      insert(target, t30, anchor);\n      insert(target, p6, anchor);\n      insert(target, t32, anchor);\n      insert(target, p7, anchor);\n      insert(target, t34, anchor);\n      insert(target, p8, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(section.$$.fragment, local);\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(section.$$.fragment, local);\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(h2);\n        detach(t5);\n        detach(h3);\n        detach(t7);\n        detach(p1);\n        detach(t9);\n        detach(ul);\n        detach(t11);\n        detach(p2);\n        detach(t13);\n        detach(ol);\n        detach(t15);\n        detach(p3);\n        detach(t17);\n        detach(h11);\n        detach(t19);\n        detach(t20);\n        detach(br0);\n        detach(t21);\n        detach(br1);\n        detach(t22);\n        detach(p4);\n        detach(t26);\n        detach(p5);\n        detach(t29);\n        detach(t30);\n        detach(p6);\n        detach(t32);\n        detach(p7);\n        detach(t34);\n        detach(p8);\n      }\n      destroy_component(section, detaching);\n      destroy_component(person, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  }
}