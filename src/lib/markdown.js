export const events_compiledmap={
  "WP02": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WP03": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP11": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#General Guidelines\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"https://docs.google.com/document/d/1gDyiRyIO8QCF-vO_uOsYcWAJL1IKcRaO7n2yqY-qmI4/edit?tab=t.0\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"LABYRINTH\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"18-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Petrichor\\u201925 presents Labyrinth, in which teams have to build an autonomous robot that can follow white lines and keep track of directions while going through the maze. The robot has to go through the path, reach the end point in the dry run, and then go from the starting point to the ending point in the shortest path in the actual run.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Date of Event: 18 January, 2025</li> <li>Time: 2 PM</li> <li>Venue: IIT Palakkad, Nila Campus</li> <li>Team Size: 1 to 4 members</li> <li>Open for everyone.</li> <li>For details about the event please refer to the Rulebook.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Ravikrishnan R\",\n      phone: \"7200198510\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Anant Jain\", phone: \"9999433882\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section;\n  let t1;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section = new Section_default({\n    props: {\n      name: \"General Guidelines\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section.$$.fragment);\n      t1 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP12": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#General Guidelines\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"https://docs.google.com/document/d/1A0TY-LFW7Tp3rZRVKiVsPws4Sajqmc4vDJ4KSVcv5ZY/edit?usp=drivesdk\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"ROBOWARS\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"19-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Get ready to witness the perfect fusion of engineering, strategy, and adrenaline! RoboWars is a high-octane competition where teams pit their custom-built robots against each other in a thrilling combat arena. It\\u2019s a platform for innovators, tech enthusiasts, and problem-solvers to showcase their creativity and technical skills.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Date of Event: 19 January, 2025</li> <li>Time: 2 PM</li> <li>Venue: IIT Palakkad, Nila Campus</li> <li>Team Size: 1 to 4 members</li> <li>Open for everyone.</li> <li>For details about the event please refer to the Rulebook.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section;\n  let t1;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section = new Section_default({\n    props: {\n      name: \"General Guidelines\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section.$$.fragment);\n      t1 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TF13": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#General Guidelines\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"https://docs.google.com/document/d/1Ny36Ye_ZH2R-J0ycw5X4WTNNvg3MQh0455GzQB2hBCk/edit?usp=drivesdk\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Quizznare: School Quiz Edition\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Whether you\\u2019re a trivia master or just here to enjoy the fun, we have some intriguing questions lined up for you. So, get ready to put your thinking caps on, work together (if you\\u2019re in a team), and let\\u2019s see who will emerge as the ultimate quiz champion!\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Date of Event: 18 January, 2025</li> <li>Time: 2 PM</li> <li>Venue: IIT Palakkad, Nila Campus</li> <li>Team Size: 1 to 4 members</li> <li>Open for everyone.</li> <li>For details about the event please refer to the Rulebook.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section;\n  let t1;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section = new Section_default({\n    props: {\n      name: \"General Guidelines\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section.$$.fragment);\n      t1 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP09": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#General Guidelines\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"https://docs.google.com/document/d/1gDyiRyIO8QCF-vO_uOsYcWAJL1IKcRaO7n2yqY-qmI4/edit?tab=t.0\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"DRONE DASH\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"18-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Petrichor\\u201925 presents Drone Dash, an adrenaline-pumping drone racing competition.\\nParticipants will pilot their drones through a challenging obstacle course, testing their speed, agility, and precision.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Date of Event: 18 January, 2025</li> <li>Time: 2 PM</li> <li>Venue: IIT Palakkad, Nila Campus</li> <li>Team Size: 1 to 4 members</li> <li>Open for everyone.</li> <li>For details about the event please refer to the Rulebook.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Shravani\", phone: \"9307570299\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Vikash Kumar\",\n      phone: \"6204196916\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section;\n  let t1;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section = new Section_default({\n    props: {\n      name: \"General Guidelines\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section.$$.fragment);\n      t1 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF08": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#event-info\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Groove Mania 2.0\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Join us for an unforgettable night of dance, creativity, and celebration of talent. Don\\u2019t miss out on this opportunity to dazzle the audience with your moves. See you on the dance floor!\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  let t10;\n  let p;\n  let t13;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Details\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Registration Starts</strong>: Yet To Be Announced</li> <li><strong>Registration Ends</strong>: Yet To Be Announced</li> <li><strong>Event Dates</strong>: 18th and 19th of January</li>`;\n      t10 = space();\n      p = element(\"p\");\n      p.innerHTML = `<strong>Note</strong>:`;\n      t13 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>No duos (can take help for dialogues).</li> <li>Open for all.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n      insert(target, t10, anchor);\n      insert(target, p, anchor);\n      insert(target, t13, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n        detach(t10);\n        detach(p);\n        detach(t13);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let h30;\n  let t3;\n  let ul;\n  let t19;\n  let h31;\n  let t21;\n  let p;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Structure\";\n      t1 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Round 1 (Online)\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must shoot a video of themselves dancing in any style.</li> <li><strong>Video Duration</strong>: 2 to 3 minutes.</li> <li>The video must have clear sound and visuals and should be a recording of a live performance with a clear face in one take.</li> <li>Upload the video in <code>.mp4</code> format to Google Drive and submit the link through the Google Form provided via your registered email ID.</li> <li><strong>Submission Deadline</strong>: Yet To Be Announced.</li> <li>Only one submission per participant is allowed.</li>`;\n      t19 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Round 2 (Offline)\";\n      t21 = space();\n      p = element(\"p\");\n      p.textContent = \"Participants advancing to the offline round will compete live at the venue.\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h30, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n      insert(target, t19, anchor);\n      insert(target, h31, anchor);\n      insert(target, t21, anchor);\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h30);\n        detach(t3);\n        detach(ul);\n        detach(t19);\n        detach(h31);\n        detach(t21);\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Any dance style is allowed.</li> <li>Participants should avoid indecent dress, songs, and gestures.</li> <li>Stunts that pose a life risk are not permitted.</li> <li>The use of fire, sharp objects, or other dangerous elements on stage is strictly prohibited.</li> <li>It is mandatory for all participants to be present at the venue before the competition begins.</li> <li>Any last-minute changes or requests should be communicated to the event coordinators well in advance.</li> <li>The judges\\u2019 decisions are final and cannot be disputed.</li> <li>All participants must display good sportsmanship and respect towards fellow participants, organizers, and judges.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Judging Criteria\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>Choreography and Creativity</li> <li>Synchronization and Expressions</li> <li>Energy and Stage Presence</li> <li>Costume and Appearance</li> <li>Overall Entertainment Value</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Prizes\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Prize</strong>: Rs. 3000</li> <li><strong>2nd Prize</strong>: Rs. 2000</li> <li><strong>3rd Prize</strong>: Rs. 1000</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Keerthana K\", phone: \"7013477128\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Bavanamrutha P\",\n      phone: \"9985049999\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"event-info\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"judging-criteria\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF07": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#event-info\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Step Up: The Ultimate Dance Battle\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"\\u201CA head-to-head showdown where dancers battle it out, move for move, to claim the spotlight and the title of ultimate dance champion!\\u201D\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Important Dates\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Start of Registration</strong>: Yet To Be Announced</li> <li><strong>End of Registration</strong>: Yet To Be Announced</li> <li><strong>Event Date</strong>: Yet To Be Announced</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"General Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>All participants must report at the venue 30 minutes before the event time and must stay throughout the event.</li> <li>Inflammable objects, water, risky stunts, and heavy props are not permitted.</li> <li>The judge\\u2019s decisions will be final, and any kind of misbehavior will result in disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let ul0;\n  let t5;\n  let h30;\n  let t7;\n  let p;\n  let t9;\n  let h31;\n  let t11;\n  let ul1;\n  let t17;\n  let h32;\n  let t19;\n  let ul2;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Rules\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>The event will be held in <strong>three rounds</strong>:</li>`;\n      t5 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Round 1:\";\n      t7 = space();\n      p = element(\"p\");\n      p.textContent = \"Participants will dance to varied and unpredictable beats, showcasing their ability to sync with the rhythm. The best performers will advance to the next round.\";\n      t9 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Round 2:\";\n      t11 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>12 selected participants will be paired into 6 groups, with two dancers in each group competing in 1 vs 1 battles.</li> <li>Each team will face off in two rounds with two different songs, giving 30 seconds and 20 seconds per round respectively, for a total of 50 seconds.</li> <li>The top 6 performers will advance to the final round.</li>`;\n      t17 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Round 3:\";\n      t19 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>The top 6 participants will be assigned numbers, and pairs will be selected randomly for 1 vs 1 battles.</li> <li>The winners of these battles will emerge as the top three performers and will be rewarded.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t5, anchor);\n      insert(target, h30, anchor);\n      insert(target, t7, anchor);\n      insert(target, p, anchor);\n      insert(target, t9, anchor);\n      insert(target, h31, anchor);\n      insert(target, t11, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t17, anchor);\n      insert(target, h32, anchor);\n      insert(target, t19, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul0);\n        detach(t5);\n        detach(h30);\n        detach(t7);\n        detach(p);\n        detach(t9);\n        detach(h31);\n        detach(t11);\n        detach(ul1);\n        detach(t17);\n        detach(h32);\n        detach(t19);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Judging Criteria\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>Execution</li> <li>Creativity and originality</li> <li>Energy and dynamics</li> <li>Performance of various styles</li> <li>Sync to the beat</li> <li>Spontaneity</li> <li>Crowd pulling</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Prizes\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>1st Place</strong>: Rs. 3500</li> <li><strong>2nd Place</strong>: Rs. 2500</li> <li><strong>3rd Place</strong>: Rs. 1500</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Keerthana K\", phone: \"7013477128\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Bavanamrutha P\",\n      phone: \"9985049999\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"event-info\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"general-rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"judging-criteria\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP04": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Capture the Flag\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"12-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Cipherify is a thrilling Capture the Flag (CTF) event where the participants are expected to showcase their cybersecurity, problem-solving, and hacking skills in a competitive and time-sensitive environment. Whether you are a beginner or an experienced elite, the event will feature challenges across categories like cryptography, reverse engineering, web exploitation, forensics, and more. The goal is simple: get the flag, find the hidden \\u201Cflags,\\u201D and earn points to climb the leaderboard.\\nThis 6-hour-long competition will challenge your technical expertise, analytical thinking, and teamwork. Whether you\\u2019re a solo player or part of a team, Cipherify promises a unique experience. Get ready to capture the flag!\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The CTF will be jeopardy-style (please Google it if you are new to this).</li> <li>Sharing of flags with other teams is not allowed.</li> <li>In case of any discrepancy, the decision of the event coordinators will be considered final.</li> <li>The platform for the CTF and the credentials will be mailed to the registered participants a week before the event.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let h40;\n  let t3;\n  let ul0;\n  let t12;\n  let h41;\n  let t14;\n  let ul1;\n  let t16;\n  let h31;\n  let t18;\n  let ul2;\n  let t27;\n  let h32;\n  let t29;\n  let ul3;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Requirements\";\n      t1 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"Event Infrastructure:\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><b>Server:</b> A DigitalOcean server to host the Docker-based CTF challenges and scoreboard.</li> <li><b>Configuration:</b> Minimum 4 vCPU, 8GB RAM, and SSD storage.</li> <li><b>Docker:</b> All challenges will be containerized using Docker for security and portability.</li>`;\n      t12 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"Participation Requirements:\";\n      t14 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Participants may register individually or in teams of up to 2 members.</li>`;\n      t16 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Duration\";\n      t18 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li><b>Event Length:</b> 6 hours</li> <li><b>Date:</b> 12th of January</li> <li><b>Time:</b> 3 PM to 9 PM</li>`;\n      t27 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Prize Money\";\n      t29 = space();\n      ul3 = element(\"ul\");\n      ul3.innerHTML = `<li><b>1st Prize:</b> 10k</li> <li><b>2nd Prize:</b> 6k</li> <li><b>3rd Prize:</b> 4k</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, h40, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, h41, anchor);\n      insert(target, t14, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t16, anchor);\n      insert(target, h31, anchor);\n      insert(target, t18, anchor);\n      insert(target, ul2, anchor);\n      insert(target, t27, anchor);\n      insert(target, h32, anchor);\n      insert(target, t29, anchor);\n      insert(target, ul3, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(h40);\n        detach(t3);\n        detach(ul0);\n        detach(t12);\n        detach(h41);\n        detach(t14);\n        detach(ul1);\n        detach(t16);\n        detach(h31);\n        detach(t18);\n        detach(ul2);\n        detach(t27);\n        detach(h32);\n        detach(t29);\n        detach(ul3);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Kshitij Ghodake\",\n      phone: \"7298991001\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Yazeed Nassar\",\n      phone: \"8593930099\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP08": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_13(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_12(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_11(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_13] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"\",\n      $$slots: { default: [create_default_slot_12] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Chipcraft\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"12-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"ChipCraft 2.0 is an exciting event focused on mastering circuit debugging techniques, exploring the latest tools and methodologies in circuit design and troubleshooting. Get ready to explore and enhance your problem-solving skills and gain valuable insights into optimizing circuit performance by competing against the best minds out there.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let h3;\n  let t1;\n  let p;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Description\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"This competition challenges your understanding of electronics and your ability to solve real-world design problems. The competition consists of two rounds: a Pen-Paper QnA followed by a Design and Debug round.\";\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Instructions\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Team Size:</strong> 1-2</li> <li><strong>Maximum Teams:</strong> 20</li> <li><strong>Mode:</strong> Offline</li> <li><strong>Rounds:</strong> 2 (Pen-Paper QnA and Simulation-based Design-Debug)</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prerequisites\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Laptop with LTSpice installed</li> <li>Basic understanding of electronics and circuit design</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul0;\n  let t11;\n  let h4;\n  let t13;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Round 01: Pen-Paper QnA\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"A written test covering basic electronics, focusing on Analog and Digital circuits. Questions will be designed to test conceptual understanding and problem-solving skills, with an emphasis on tricky scenarios.\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Number of Questions:</strong> 20 (may include sub-tasks)</li> <li><strong>Duration:</strong> Approximately 1 hour 30 minutes</li> <li>Top 7 teams based on performance will qualify for Round-02</li>`;\n      t11 = space();\n      h4 = element(\"h4\");\n      h4.textContent = \"Rules\";\n      t13 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Each team must submit one answer booklet to volunteers.</li> <li>Use of electronic devices and reference materials is strictly prohibited.</li> <li>Late submissions will not be entertained.</li> <li>The decision of the evaluators will be final.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t11, anchor);\n      insert(target, h4, anchor);\n      insert(target, t13, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul0);\n        detach(t11);\n        detach(h4);\n        detach(t13);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul0;\n  let t12;\n  let h40;\n  let t14;\n  let ul1;\n  let t18;\n  let h41;\n  let t20;\n  let ul2;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Round 02: Design and Debug\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Teams will engage in practical problem-solving, involving circuit design and debugging (Simulations on LTSpice). Tasks will be based on basic electronic components and their applications.\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Number of Questions:</strong> 10 (may include sub-tasks)</li> <li><strong>Duration:</strong> 2 hours</li> <li><strong>Evaluation:</strong> Teams must demonstrate their solutions (in simulation) to the volunteers for assessment</li>`;\n      t12 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"Resources Provided to Participants\";\n      t14 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>LTSpice Model / Circuit for Debugging</li> <li>Relevant datasheets of components (For designing part)</li>`;\n      t18 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"Rules\";\n      t20 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Tasks must be completed within the given timeframe.</li> <li>Usage of the Internet is prohibited.</li> <li>Hints will be provided if there\\u2019s no objection from other participants.</li> <li>The decision of the evaluators will be final.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, h40, anchor);\n      insert(target, t14, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t18, anchor);\n      insert(target, h41, anchor);\n      insert(target, t20, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul0);\n        detach(t12);\n        detach(h40);\n        detach(t14);\n        detach(ul1);\n        detach(t18);\n        detach(h41);\n        detach(t20);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Evaluation Method\";\n      t1 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Round 01:</strong> Scored based on the accuracy and completeness of answers.</li> <li><strong>Round 02:</strong> Judged based on:\n      <ul><li>Correctness of the solution</li> <li>Efficient usage of components to solve the problem</li> <li>Clarity in demonstrating the results/approach to volunteers</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>First Prize:</strong> Rs 5,000</li> <li><strong>Second Prize:</strong> Rs 3,000</li> <li><strong>Third Prize:</strong> Rs 2,000</li> <li>Participation certificates will be awarded to all participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Harikrishnan S\",\n      phone: \"94951 83524\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Sidharth Saji\",\n      phone: \"96055 17615\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h3;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let section5;\n  let t6;\n  let section6;\n  let t7;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"description\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"general-instructions\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"prerequisites\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"round-01\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"round-02\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section5 = new Section_default({\n    props: {\n      name: \"evaluation-method\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section6 = new Section_default({\n    props: {\n      name: \"prize-pool\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(section5.$$.fragment);\n      t6 = space();\n      create_component(section6.$$.fragment);\n      t7 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(section5, target, anchor);\n      insert(target, t6, anchor);\n      mount_component(section6, target, anchor);\n      insert(target, t7, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const section5_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section5_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section5.$set(section5_changes);\n      const section6_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section6_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section6.$set(section6_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(section5.$$.fragment, local);\n      transition_in(section6.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(section5.$$.fragment, local);\n      transition_out(section6.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n        detach(t6);\n        detach(t7);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(section5, detaching);\n      destroy_component(section6, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP05": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_12(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Tournament Details\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_11(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#tournament-info\",\n      $$slots: { default: [create_default_slot_12] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Free Fire: The Ultimate Showdown\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Helloooooooo, Everyone!\\nGet ready to level up your skills and rally your squad because things are about to heat up!\\nPetrichor proudly presents an electrifying FF tournament, where the best of the best come together to battle it out and claim the ultimate glory. Who will rise to the top? It\\u2019s time to find out!\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let ul;\n  let t7;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Tournment Details\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"To ensure a fair and dynamic competition, the tournament unfolds in two stages:\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The Trials</li> <li>The Grand Conquest</li>`;\n      t7 = text(\"\\nEach stage comes with its own set of challenges, promising every team a chance to rise.\");\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n      insert(target, t7, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul);\n        detach(t7);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h3;\n  let t1;\n  let h40;\n  let t3;\n  let ul2;\n  let t19;\n  let h41;\n  let t21;\n  let ul5;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Stage Breakdown\";\n      t1 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"The Trials\";\n      t3 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Game Mode: Battle Royale</li> <li>Dates: 11/01/2025</li> <li>Format:\n    <ul><li>Team Size: 5 main players + 1 substitute</li> <li>Maps: Bermuda, Purgatory, Alpine</li> <li>Rounds: Each qualifier features 3 matches</li></ul></li> <li>Advancement:\n    <ul><li>Top 2 teams from each qualifier advance to finals</li> <li>Next best teams compete in a wildcard match for remaining spots</li></ul></li>`;\n      t19 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"The Grand Conquest\";\n      t21 = space();\n      ul5 = element(\"ul\");\n      ul5.innerHTML = `<li>Dates: 11/01/2025</li> <li>Format:\n    <ul><li>Maps: Bermuda, Purgatory, Alpine, Kalahari, Nexterra</li> <li>Matches: 5 games to decide the champion</li></ul></li> <li>Winner Determination:\n    <ul><li>Points based on rank and kills</li> <li>Tiebreaker rules apply if necessary</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, h40, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul2, anchor);\n      insert(target, t19, anchor);\n      insert(target, h41, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul5, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(h40);\n        detach(t3);\n        detach(ul2);\n        detach(t19);\n        detach(h41);\n        detach(t21);\n        detach(ul5);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h3;\n  let t1;\n  let h40;\n  let t3;\n  let ul0;\n  let t15;\n  let h41;\n  let t17;\n  let ul1;\n  let t19;\n  let h42;\n  let t21;\n  let ul2;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Scoring System\";\n      t1 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"Rank Points\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Rank 1: 20 points</li> <li>Rank 2: 16 points</li> <li>Rank 3: 12 points</li> <li>Rank 4: 8 points</li> <li>Rank 5: 4 points</li> <li>Rank 6-10: 1 point</li>`;\n      t15 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"Kill Points\";\n      t17 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>1 point per kill</li>`;\n      t19 = space();\n      h42 = element(\"h4\");\n      h42.textContent = \"Total Points Calculation\";\n      t21 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Total Points = Rank Points + Kill Points</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, h40, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t15, anchor);\n      insert(target, h41, anchor);\n      insert(target, t17, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t19, anchor);\n      insert(target, h42, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(h40);\n        detach(t3);\n        detach(ul0);\n        detach(t15);\n        detach(h41);\n        detach(t17);\n        detach(ul1);\n        detach(t19);\n        detach(h42);\n        detach(t21);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Matchmaking Settings\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Team Size: 5 players + substitute</li> <li>HP: 200</li> <li>Movement Speed: 100%</li> <li>Environment: Day</li> <li>Fall Damage: Yes</li> <li>Airdrop: Yes</li> <li>Vehicles: Yes</li> <li>UAV: Yes</li> <li>EP: 100</li> <li>Jump Height: 100%</li> <li>Limited Ammo: Yes</li> <li>Loadout: Yes</li> <li>Character Skill: Yes</li> <li>Airstrike: Yes</li> <li>Death Spectate: No</li> <li>Save Replays: Yes</li> <li>Hide Nickname: Yes</li> <li>Revival: Yes</li> <li>Gun Property: No</li> <li>Kill Feed: No</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p;\n  let t3;\n  let ul0;\n  let t13;\n  let h4;\n  let t15;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Wild Card Entry\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"The Wild Card Entry is the final chance for teams to secure their place in the Grand Conquest Finals.\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Mode: Battle Royale</li> <li>Maps: Bermuda, Alpine</li> <li>Scoring: Based on rank and kills</li> <li>Top teams with the highest points advance to Finals</li> <li>In case of a tie, a Counter-Strike (CS) match will decide the winner.</li>`;\n      t13 = space();\n      h4 = element(\"h4\");\n      h4.textContent = \"CS Tie-Breaker\";\n      t15 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Mode: Competitive</li> <li>Team Size: 5 players</li> <li>Map: [Specify Map]</li> <li>Start Money: $800</li> <li>Format: Best-of-one</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t13, anchor);\n      insert(target, h4, anchor);\n      insert(target, t15, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul0);\n        detach(t13);\n        detach(h4);\n        detach(t15);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Registration: One team per player, substitutes must be pre-registered</li> <li>Devices: No rooted/jailbroken devices, emulators, or controllers</li> <li>Conduct: Offensive language or spamming is prohibited</li> <li>Integrity: Exploiting glitches or changing in-game names is forbidden</li> <li>Punctuality: Teams must join within the allotted time</li> <li>Compliance: Matches may be monitored or live-streamed; IDs may be verified</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul0;\n  let t10;\n  let ul1;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool and Registration\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><b>1st Prize:</b> 2,500</li> <li><b>2nd Prize:</b> 1,500</li> <li><b>3rd Prize:</b> 1,000</li>`;\n      t10 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Registration Fee: 100 per team</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t10, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul0);\n        detach(t10);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"B.Dhan Siddhartha\",\n      phone: \"+91 79954 42818\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Jugdeep Roy\",\n      phone: \"+91 81015 57970\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let section5;\n  let t6;\n  let section6;\n  let t7;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"tournament-info\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"stage-breakdown\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"scoring\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"matchmaking\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"wildcard\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section5 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section6 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(section5.$$.fragment);\n      t6 = space();\n      create_component(section6.$$.fragment);\n      t7 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(section5, target, anchor);\n      insert(target, t6, anchor);\n      mount_component(section6, target, anchor);\n      insert(target, t7, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const section5_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section5_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section5.$set(section5_changes);\n      const section6_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section6_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section6.$set(section6_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(section5.$$.fragment, local);\n      transition_in(section6.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(section5.$$.fragment, local);\n      transition_out(section6.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n        detach(t6);\n        detach(t7);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(section5, detaching);\n      destroy_component(section6, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP05": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"RubikVerse\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"18-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"The Rubik\\u2019s Cube event is an exhilarating challenge designed to test participants\\u2019 problem-solving abilities, speed, and dexterity. Enthusiasts from all skill levels come together to showcase their talent in solving these iconic puzzles across multiple categories.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h30;\n  let t1;\n  let p;\n  let t3;\n  let ul0;\n  let t11;\n  let h31;\n  let t13;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Problem Statement\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Participants will be required to solve Rubik\\u2019s Cubes under specified formats and conditions, competing against others to achieve the fastest time. The categories include:\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>2x2x2 Rubik&#39;s Cube</li> <li>3x3x3 Rubik&#39;s Cube</li> <li>3x3x3 One-Handed</li> <li>3x3x3 Team Relay</li>`;\n      t11 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Judging Criteria\";\n      t13 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>The individual/team with the lower time to solve the cube will be declared as the winner.</li> <li><b>Individual event criteria:</b></li> <ul><li><b>2x2x2 and 3x3x3 Events:</b> Time taken to solve the puzzle is the sole criterion.</li> <li><b>3x3x3 One-Handed:</b> The cube must be solved entirely using one hand; using the other hand will incur penalties or disqualification.</li> <li><b>3x3x3 Team Relay:</b> This event happens in teams of 3, where all 3 people will be solving a 3x3x3 cube one after the other. The timer starts when the first person starts solving and stops when the last person finishes solving.</li></ul>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t11, anchor);\n      insert(target, h31, anchor);\n      insert(target, t13, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(p);\n        detach(t3);\n        detach(ul0);\n        detach(t11);\n        detach(h31);\n        detach(t13);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let h31;\n  let t3;\n  let table;\n  let t23;\n  let h32;\n  let t25;\n  let ul2;\n  let t38;\n  let h33;\n  let t40;\n  let ul3;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Schedule\";\n      t1 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Schedule\";\n      t3 = space();\n      table = element(\"table\");\n      table.innerHTML = `<thead><tr style=\"border: 1px solid black;\"><th style=\"border: 1px solid black; padding: 8px;\">Time</th> <th style=\"border: 1px solid black; padding: 8px;\">Round</th></tr></thead> <tbody><tr style=\"border: 1px solid black;\"><td style=\"border: 1px solid black; padding: 8px;\">From 10 AM onwards</td> <td style=\"border: 1px solid black; padding: 8px;\"><ul><li>2x2x2 - Round 1 - 3 solves - 2 min/solve - Top 5 will be selected</li> <li>3x3x3 - Round 1 - 3 solves - 2.5 min/solve - Top 10 will be selected</li></ul></td></tr> <tr style=\"border: 1px solid black;\"><td style=\"border: 1px solid black; padding: 8px;\">Immediately after Round 1</td> <td style=\"border: 1px solid black; padding: 8px;\"><ul><li>2x2x2 Final - 5 solves</li> <li>3x3x3 Final - 5 solves</li> <li>3x3x3 One-Handed Final Round - 5 solves</li> <li>3x3x3 Team Relay - 3 solves</li></ul></td></tr></tbody>`;\n      t23 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Prize Pool\";\n      t25 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li>Only the one with lesser time will be announced as the winner.</li> <li><b>First Prize:</b> 3k</li> <li><b>Second Prize:</b> 1.5k</li> <li><b>Third Prize:</b> 500</li> <li>Participation certificates will be awarded to all participants.</li>`;\n      t38 = space();\n      h33 = element(\"h3\");\n      h33.textContent = \"Note:\";\n      t40 = space();\n      ul3 = element(\"ul\");\n      ul3.innerHTML = `<li><b>Team Formation:</b> Individual participation except for the 3x3 relay event.</li> <li>Participants must bring their own cube for the respective competition. If an individual fails to bring their cube, they will be disqualified.</li>`;\n      set_style(table, \"border-collapse\", \"collapse\");\n      set_style(table, \"width\", \"100%\");\n      set_style(table, \"text-align\", \"left\");\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, h31, anchor);\n      insert(target, t3, anchor);\n      insert(target, table, anchor);\n      insert(target, t23, anchor);\n      insert(target, h32, anchor);\n      insert(target, t25, anchor);\n      insert(target, ul2, anchor);\n      insert(target, t38, anchor);\n      insert(target, h33, anchor);\n      insert(target, t40, anchor);\n      insert(target, ul3, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(h31);\n        detach(t3);\n        detach(table);\n        detach(t23);\n        detach(h32);\n        detach(t25);\n        detach(ul2);\n        detach(t38);\n        detach(h33);\n        detach(t40);\n        detach(ul3);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Nagendra Arasan\",\n      phone: \"9445771140\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Alphin Issac\",\n      phone: \"8921974858\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP06": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"AlgoTrek\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"12-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"We are thrilled to invite you to the Petrichor 2025 Competitive Programming Contest AlgoTrek 2.0, a thrilling battle of wits and algorithms. Get ready to unleash your coding prowess, sharpen your problem-solving skills, and compete with the best minds out there.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>It\\u2019s an individual contest, not a team contest.</li> <li>Participants are not allowed to communicate with other participants, use another person\\u2019s code for solutions/generators, or share ideas of solutions.</li> <li>Participants are not allowed to use multiple accounts and must participate in the contest using only their personal and single account.</li> <li>Using third-party codes from other websites, such as GeeksforGeeks, is prohibited.</li> <li>An ID will be allocated to the participants upon registration, which shall be used for future references.</li> <li>All modes of official communication will be through Petrichor&#39;s email.</li> <li>Participants are advised to keep track of all folders in their email accounts.</li> <li>In case plagiarism is found in a candidate&#39;s code, that candidate will be disqualified from the contest and barred from receiving any prizes.</li> <li>Participants must fill the online form to participate in the contest.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let ul0;\n  let t19;\n  let h31;\n  let t21;\n  let ul1;\n  let t27;\n  let h32;\n  let t29;\n  let ul2;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Information\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Date of Event:</strong> 11th January, 2025</li> <li><strong>Time:</strong> 8 PM</li> <li><strong>Team Participation:</strong> Individual</li> <li><strong>Opportunity Open For:</strong> College students</li> <li><strong>Coding Platform:</strong> Codechef Contest</li> <li><strong>Link:</strong> [To be provided]</li>`;\n      t19 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Structure\";\n      t21 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>One CP contest of 2.5 hours where winners will be selected through a common leaderboard.</li> <li>Registration fee: 79</li> <li>Contest link will be sent to your registered mail ID.</li>`;\n      t27 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Prize\";\n      t29 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li><strong>1st Position:</strong> Rs 5500</li> <li><strong>2nd Position:</strong> Rs 4500</li> <li><strong>3rd Position:</strong> Rs 3500</li> <li><strong>4th Position:</strong> Rs 2500</li> <li><strong>5th Position:</strong> Rs 1500</li> <li><strong>6th to 20th Positions:</strong> Rs 500 each</li> <li>Participation certificates will be awarded to all participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t19, anchor);\n      insert(target, h31, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t27, anchor);\n      insert(target, h32, anchor);\n      insert(target, t29, anchor);\n      insert(target, ul2, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(ul0);\n        detach(t19);\n        detach(h31);\n        detach(t21);\n        detach(ul1);\n        detach(t27);\n        detach(h32);\n        detach(t29);\n        detach(ul2);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t0;\n  let person1;\n  let t1;\n  let person2;\n  let t2;\n  let person3;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Asaduddin Ahmed\",\n      phone: \"6281178386\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Devansh Kesan\",\n      phone: \"8010782121\"\n    }\n  });\n  person2 = new Person_default({\n    props: { name: \"Aman Rahman\", phone: \"9635910400\" }\n  });\n  person3 = new Person_default({\n    props: { name: \"D. Udith\", phone: \"6303881167\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t0 = space();\n      create_component(person1.$$.fragment);\n      t1 = space();\n      create_component(person2.$$.fragment);\n      t2 = space();\n      create_component(person3.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(person1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(person2, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(person3, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      transition_in(person2.$$.fragment, local);\n      transition_in(person3.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      transition_out(person2.$$.fragment, local);\n      transition_out(person3.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n      destroy_component(person2, detaching);\n      destroy_component(person3, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP07": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_12(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_11(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#description\",\n      $$slots: { default: [create_default_slot_12] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Tesseract\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"11-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Tesseract is an exhilarating online treasure hunt designed to challenge your wit, problem-solving skills, and teamwork. Get ready to dive into a series of cryptic puzzles and clues, as you embark on a thrilling quest to uncover hidden treasures in the digital realm.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let h3;\n  let t1;\n  let p;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Description\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Petrichor 2025 proudly presents Tesseract, an engaging and mind-bending online treasure hunt. Participants will navigate through multiple rounds, solving cryptic clues and puzzles to progress to the next level. Sharpen your minds and embrace the challenge!\";\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Date and Time\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Duration:</strong> 4 hours</li> <li><strong>Date:</strong> 11th of January, 2025</li> <li><strong>Time:</strong> 2:00 PM to 6:00 PM</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants can sign up individually or in teams of up to 3 members.</li> <li>Team members can be from different institutions.</li> <li>Each participant can be a part of only one team.</li> <li>The treasure hunt consists of 5 rounds, each hosted on a dedicated Discord server.</li> <li>Paid hints are available for each round. Hint details will be shared with the points structure.</li> <li>Teams must verify their identity using a unique team code provided by their team leader (format: <strong>teamname@numbers</strong>).</li> <li>Faster solutions earn more points. Negative points may apply if time exceeds a limit.</li> <li>Internet-enabled laptops/computers are recommended for participation.</li> <li>At least one team member must join the Discord server.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Teams are scored based on points earned and the speed of solving clues.</li> <li>The team with the highest cumulative score at the end wins.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h3;\n  let t1;\n  let p;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Team Size\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Teams can consist of 1-3 members. Team members may belong to different institutions.\";\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Prize Pool\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>First Prize:</strong> Rs 5,000</li> <li><strong>Second Prize:</strong> Rs 3,000</li> <li><strong>Third Prize:</strong> Rs 2,000</li> <li>Participation certificates will be awarded to all participants.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Registration Procedure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Register on this website.</li> <li>Team leaders must register and add team members.</li> <li>Team leaders will receive a unique team code to use during the contest.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t0;\n  let person1;\n  let t1;\n  let person2;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Vishesh Srivastava\",\n      phone: \"81092 05264\"\n    }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Prabhat Suresh\",\n      phone: \"93451 79049\"\n    }\n  });\n  person2 = new Person_default({\n    props: {\n      name: \"Kaushik Rawat\",\n      phone: \"72087 98365\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t0 = space();\n      create_component(person1.$$.fragment);\n      t1 = space();\n      create_component(person2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(person1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(person2, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      transition_in(person2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      transition_out(person2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n      destroy_component(person2, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h3;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Organizers\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let section5;\n  let t6;\n  let section6;\n  let t7;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"description\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"date-time\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"judging-criteria\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"team-size\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section5 = new Section_default({\n    props: {\n      name: \"prize-pool\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section6 = new Section_default({\n    props: {\n      name: \"registration\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(section5.$$.fragment);\n      t6 = space();\n      create_component(section6.$$.fragment);\n      t7 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(section5, target, anchor);\n      insert(target, t6, anchor);\n      mount_component(section6, target, anchor);\n      insert(target, t7, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const section5_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section5_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section5.$set(section5_changes);\n      const section6_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section6_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section6.$set(section6_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(section5.$$.fragment, local);\n      transition_in(section6.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(section5.$$.fragment, local);\n      transition_out(section6.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n        detach(t6);\n        detach(t7);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(section5, detaching);\n      destroy_component(section6, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF06": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_11(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Tournment Info\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#event-info\",\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Valorant\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"An exciting Valorant tournament open to all, with thrilling matches and a grand prize pool!\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Tournment Details\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Registration Start</strong>: 5-1-2025</li> <li><strong>Registration End</strong>: 10-1-2025</li> <li><strong>Event Date</strong>: 12-1-2025</li> <li><strong>Team Composition</strong>: 5 players + 1 substitute player (optional) per team</li> <li><strong>Eligibility</strong>: Open to all</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let ul1;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Precautions\";\n      t1 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>All team members must download and test all maps before the tournament. Ensure stable internet connectivity.</li> <li><strong>Check-In Rules</strong>: Team captains must check in at least 10 minutes before their scheduled match. Late check-ins could lead to penalties or disqualification.</li> <li><strong>Player Availability</strong>: Teams with only 4 players can compete in a 4v5 match. Late players cannot join mid-game but may join for subsequent matches.</li> <li><strong>Rule Flexibility</strong>: Tournament staff have the final authority in unforeseen situations. Rules may be adjusted to maintain fairness, such as map removal for technical reasons.</li> <li><strong>Technical Pause</strong>: Maximum of 5 minutes per match for technical issues.</li> <li><strong>Penalties</strong>:  \n<ul><li>Cheating: Immediate disqualification.</li> <li>Toxic behavior: Warnings, then removal from the tournament.</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let h30;\n  let t3;\n  let ul0;\n  let t9;\n  let h31;\n  let t11;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Tournament Rules\";\n      t1 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Structure:\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><strong>Format</strong>: Single elimination. Teams are eliminated after one loss.</li> <li><strong>Match Type</strong>: All matches are in Unrated mode (5v5).</li>`;\n      t9 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Stages:\";\n      t11 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li><p><strong>First Round (Knockouts)</strong>:</p> <ul><li>Teams are randomly paired to compete.</li> <li>Winners advance to the next stage.</li></ul></li> <li><p><strong>Quarter-Finals &amp; Semi-Finals</strong>:</p> <ul><li>Matches follow the same format (Unrated, first to 13).</li></ul></li> <li><p><strong>Finals</strong>:</p> <ul><li><strong>Best of 3</strong>: Teams play up to three matches, and the first team to win 2 matches becomes the tournament champion.</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h30, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t9, anchor);\n      insert(target, h31, anchor);\n      insert(target, t11, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h30);\n        detach(t3);\n        detach(ul0);\n        detach(t9);\n        detach(h31);\n        detach(t11);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Map Selection\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li><p><strong>First Round</strong>:<br/>\nMaps are randomly assigned by the organizers.</p></li> <li><p><strong>Quarter-Finals and Semi-Finals</strong>:</p> <ul><li>The higher-seeded team bans one map.</li> <li>The final map is chosen randomly from the remaining pool.</li></ul></li> <li><p><strong>Finals (Best of 3 Series)</strong>:</p> <ul><li>Both teams ban one map.</li> <li>The final map is selected from the remaining maps.</li></ul></li> <li><p><strong>General Rules</strong>:</p> <ul><li>A map cannot be repeated in the same series unless all other maps have been played.</li> <li>The tournament will use the active Valorant map pool.</li> <li>Teams must finalize their choices or bans within 2 minutes during the selection process to maintain the schedule.</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let ul1;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><p><strong>Win Conditions</strong>:</p> <ul><li>Match Victory: The first team to win 13 rounds in a match is the winner.</li> <li><strong>Tie</strong>: In case of a 12-12 score, the match proceeds to Overtime, where teams alternate sides until one wins by 2 consecutive rounds.</li></ul></li> <li><p><strong>Tie-Breaker for Standings</strong>:<br/>\nTotal number of rounds won across all matches.</p></li> <li><p><strong>Substitute Player</strong>:<br/>\nA team can substitute a maximum of 1 player during the match.</p></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h1;\n  let t1;\n  let ul1;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Prize Distribution\";\n      t1 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Total Prize Pool</strong>: Rs. 5000  \n<ul><li>1st Place: Rs. 2500</li> <li>2nd Place: Rs. 1500</li> <li>3rd Place: Rs. 900</li> <li>MVP Award: Rs. 100 (\\u201CMost Valuable Player\\u201D based on performance, e.g., highest kills, clutches).</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: {\n      name: \"Prince Yadav\",\n      phone: \"1234567890\"\n    }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let section5;\n  let t6;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"event-info\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"precautions\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"tournament-rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"map-selection\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"judging-criteria\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section5 = new Section_default({\n    props: {\n      name: \"prize-distribution\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(section5.$$.fragment);\n      t6 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(section5, target, anchor);\n      insert(target, t6, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const section5_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section5_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section5.$set(section5_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(section5.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(section5.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n        detach(t6);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(section5, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP10": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Rulebook\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let button0;\n  let t0;\n  let button1;\n  let t1;\n  let button2;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#General Guidelines\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"https://docs.google.com/document/d/1wxnJVY66decK9G-xIMnNvxBJZdTnSzuSx1KMa0QFmj8/edit?tab=t.0#heading=h.xf6ljnvozil\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  button2 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t0 = space();\n      create_component(button1.$$.fragment);\n      t1 = space();\n      create_component(button2.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(button1, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(button2, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n      const button2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button2.$set(button2_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      transition_in(button2.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      transition_out(button2.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n      destroy_component(button2, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"BRIDGE BONANAZA\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"18-01-1025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Experience the excitement of creating a fully functional bridge structure in Bridge Bonanza, a flagship event of PETRICHOR 2025. This competition challenges participants to design and construct a trussed bridge framework that will face real-world load conditions and showcase their engineering ingenuity.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"General Guidelines\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Date of Event: 18 January, 2025</li> <li>Time: 2 PM</li> <li>Venue: IIT Palakkad, Nila Campus</li> <li>Team Size: 1 to 4 members</li> <li>Open for everyone.</li> <li>For details about the event please refer to the Rulebook.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Dev Mittal\", phone: \"9958293130\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Aarnava Rajan\",\n      phone: \"6363851697\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section;\n  let t1;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section = new Section_default({\n    props: {\n      name: \"General Guidelines\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section.$$.fragment);\n      t1 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF09": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_10(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#event-info\",\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"COD: Clash of Champions\";\n      t1 = space();\n      p = element(\"p\");\n      p.innerHTML = `An epic online Call of Duty: Mobile tournament for <strong>Petrichor 2025</strong>. Assemble your squad and compete for glory in this high-stakes battle of strategy and skill!`;\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Details\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Registration Start Date</strong>: [To be announced]</li> <li><strong>Registration End Date</strong>: [To be announced]</li> <li><strong>Event Date</strong>: [To be announced]</li> <li><strong>Team Size</strong>: Five (5) participants per team</li> <li><strong>Open To</strong>: Anyone</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let h30;\n  let t3;\n  let ul0;\n  let t9;\n  let h31;\n  let t11;\n  let ul3;\n  let t37;\n  let h32;\n  let t39;\n  let ul4;\n  let t44;\n  let h33;\n  let t46;\n  let ul6;\n  let t59;\n  let h34;\n  let t61;\n  let ul9;\n  let t80;\n  let h35;\n  let t82;\n  let ul10;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Rules\";\n      t1 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Tournament Format\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Single-elimination format: Teams are eliminated after losing one match.</li> <li>Teams must download all maps and check-in <strong>10 minutes before scheduled matches</strong>. Late check-ins or failure to join the lobby may lead to disqualification.</li>`;\n      t9 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Match Format\";\n      t11 = space();\n      ul3 = element(\"ul\");\n      ul3.innerHTML = `<li><strong>First Round Games</strong>:  \n<ul><li>Teams play three game modes:  \n<ol><li><strong>Team Deathmatch</strong></li> <li><strong>Hardpoint</strong></li> <li><strong>Domination</strong></li></ol></li> <li>Teams winning two games advance to the next round.</li> <li><strong>Map Selection</strong>:  \n<ul><li>Losing team of the first game selects the second map (<strong>Hardpoint</strong>).</li> <li>Losing team of the second game selects the third map (<strong>Domination</strong>).</li></ul></li></ul></li> <li><strong>Qualification</strong>: The top <strong>8 teams</strong> qualify for the quarter-finals.</li>`;\n      t37 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Quarter-Finals\";\n      t39 = space();\n      ul4 = element(\"ul\");\n      ul4.innerHTML = `<li>Follows the same format as the first round.</li> <li><strong>4 winners</strong> advance to the semi-finals.</li>`;\n      t44 = space();\n      h33 = element(\"h3\");\n      h33.textContent = \"Semi-Finals\";\n      t46 = space();\n      ul6 = element(\"ul\");\n      ul6.innerHTML = `<li><strong>Game Modes</strong>:  \n<ol><li><strong>Hardpoint</strong></li> <li><strong>Domination</strong></li> <li><strong>Search and Destroy</strong></li></ol></li> <li>Map Selection:  \n<ul><li>Hardpoint and Search and Destroy maps are pre-selected by organizers.</li> <li>Winning team of Hardpoint selects the Domination map.</li></ul></li>`;\n      t59 = space();\n      h34 = element(\"h3\");\n      h34.textContent = \"Finals\";\n      t61 = space();\n      ul9 = element(\"ul\");\n      ul9.innerHTML = `<li><strong>Match Structure</strong>:  \n<ul><li>Hardpoint</li> <li>Search and Destroy</li> <li>1v1 Series (if needed):  \n<ul><li>If each team wins one game, there will be <strong>three 1v1 matches</strong>.</li> <li>Only main players from each team participate in the 1v1 series.</li> <li>Team winning <strong>2 out of 3 matches</strong> wins.</li></ul></li> <li>If a team wins both Hardpoint and Search and Destroy, no 1v1 matches are required.</li></ul></li>`;\n      t80 = space();\n      h35 = element(\"h3\");\n      h35.textContent = \"Additional Rules\";\n      t82 = space();\n      ul10 = element(\"ul\");\n      ul10.innerHTML = `<li>Teams may substitute a player, but organizers must be informed <strong>before 2 PM</strong>.</li> <li>All roster members must have Call of Duty accounts in good standing, without bans or restrictions.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h30, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t9, anchor);\n      insert(target, h31, anchor);\n      insert(target, t11, anchor);\n      insert(target, ul3, anchor);\n      insert(target, t37, anchor);\n      insert(target, h32, anchor);\n      insert(target, t39, anchor);\n      insert(target, ul4, anchor);\n      insert(target, t44, anchor);\n      insert(target, h33, anchor);\n      insert(target, t46, anchor);\n      insert(target, ul6, anchor);\n      insert(target, t59, anchor);\n      insert(target, h34, anchor);\n      insert(target, t61, anchor);\n      insert(target, ul9, anchor);\n      insert(target, t80, anchor);\n      insert(target, h35, anchor);\n      insert(target, t82, anchor);\n      insert(target, ul10, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h30);\n        detach(t3);\n        detach(ul0);\n        detach(t9);\n        detach(h31);\n        detach(t11);\n        detach(ul3);\n        detach(t37);\n        detach(h32);\n        detach(t39);\n        detach(ul4);\n        detach(t44);\n        detach(h33);\n        detach(t46);\n        detach(ul6);\n        detach(t59);\n        detach(h34);\n        detach(t61);\n        detach(ul9);\n        detach(t80);\n        detach(h35);\n        detach(t82);\n        detach(ul10);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let h3;\n  let t3;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Judgment\";\n      t1 = space();\n      h3 = element(\"h3\");\n      h3.textContent = \"Points System\";\n      t3 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><p>Teams winning without playing Domination: <strong>5 points</strong></p></li> <li><p>Teams winning both Team Deathmatch and Domination: <strong>4 points</strong></p></li> <li><p>Teams winning Hardpoint and Domination: <strong>3 points</strong></p></li> <li><p>Teams winning by forfeit: <strong>3 points</strong></p></li> <li><p><strong>Overall Winner</strong>: The team with the highest points.</p></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h3, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h3);\n        detach(t3);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let ul1;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Prize Distribution\";\n      t1 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li><strong>Total Prize Pool</strong>: Rs. 5000  \n<ul><li><strong>1st Prize</strong>: Rs. 2500</li> <li><strong>2nd Prize</strong>: Rs. 1500</li> <li><strong>3rd Prize</strong>: Rs. 1000</li></ul></li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Additional Information\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Refer to the full tournament rules for complete details and updates.</li> <li>Ensure compliance with all guidelines to avoid disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({\n    props: {\n      name: \"Mithil Reddy\",\n      phone: \"1234567890\"\n    }\n  });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"event-info\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"judgment\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"additional-info\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CF10": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_12(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_11(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_10(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#event-info\",\n      $$slots: { default: [create_default_slot_12] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_11] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_9(ctx) {\n  let h1;\n  let t1;\n  let p;\n  let t3;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_10] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Dance Duel: Group Dance Competition\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Step into the spotlight and showcase your talent, coordination, and creativity. Compete with the best, captivate the audience, and prove your team\\u2019s mettle in this ultimate group dance showdown!\";\n      t3 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n      insert(target, t3, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n        detach(t3);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_8(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Info\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Registration Opens</strong>: [To be announced]</li> <li><strong>Registration Closes</strong>: [To be announced]</li> <li><strong>Event Date</strong>: [To be announced]</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let h1;\n  let t1;\n  let h30;\n  let t3;\n  let ul0;\n  let t19;\n  let h31;\n  let t21;\n  let ul1;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Event Structure\";\n      t1 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Round 1 (Online)\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li>Participants must shoot a video of their dance in any style.</li> <li><strong>Video Duration</strong>: 2 to 3 minutes.</li> <li>The video must have clear sound and visuals, capturing a live performance. All team members must be clearly visible.</li> <li>Upload the video in <code>.mp4</code> format to Google Drive and submit the link through the provided Google Form.</li> <li><strong>Submission Deadline</strong>: January 2024.</li> <li>Only one submission per team is allowed.</li>`;\n      t19 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Round 2 (Offline)\";\n      t21 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Top entries from the online round will be shortlisted for the final round.</li> <li>Participants must arrive at the venue <strong>at least 20 minutes</strong> before the event starts.</li> <li>Any rule violations may lead to disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, h30, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t19, anchor);\n      insert(target, h31, anchor);\n      insert(target, t21, anchor);\n      insert(target, ul1, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(h30);\n        detach(t3);\n        detach(ul0);\n        detach(t19);\n        detach(h31);\n        detach(t21);\n        detach(ul1);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let h1;\n  let t1;\n  let ol;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"General Guidelines\";\n      t1 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li><strong>Team Composition</strong>: Teams must consist of 3 to 15 participants.</li> <li><strong>Eligibility</strong>: Open to participants of all age groups and backgrounds.</li> <li><strong>Performance Duration</strong>: Each team has a total of <strong>15 minutes</strong>, including setup and clearing time. Exceeding this limit will result in penalties.</li> <li><strong>Song Submission</strong>: Submit all performance tracks through the designated form before the provided deadline.</li> <li><strong>Attire and Conduct</strong>: Participants must wear appropriate costumes and avoid offensive gestures or song selections.</li> <li><strong>Props and Safety</strong>: Teams are responsible for their props and costumes. Hazardous materials like fire, sharp objects, or unsafe items are prohibited.</li> <li><strong>Timing</strong>: Teams must report to the venue <strong>20 minutes before the event</strong> and be backstage <strong>5 minutes before their slot</strong>.</li> <li><strong>Communication</strong>: Convey any last-minute changes or requirements to event coordinators promptly.</li> <li><strong>Respect and Integrity</strong>: Exhibit sportsmanship and respect towards other teams, organizers, and judges.</li> <li><strong>Final Decisions</strong>: Judges\\u2019 decisions are conclusive and cannot be challenged.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ol, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ol);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Performance Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Dance Styles</strong>: All dance forms are welcome.</li> <li><strong>Time Management</strong>: Performances must adhere to the allocated 15-minute slot.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Judging Criteria\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>Choreography and Creativity</strong>: 30 points</li> <li><strong>Synchronization and Expressions</strong>: 25 points</li> <li><strong>Energy and Stage Presence</strong>: 25 points</li> <li><strong>Costume and Appearance</strong>: 20 points</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Prizes\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li><strong>First Prize</strong>: [To be announced]</li> <li><strong>Second Prize</strong>: [To be announced]</li> <li><strong>Third Prize</strong>: [To be announced]</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h1;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Additional Information\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Maintain venue decorum and cooperate with event staff for a smooth experience.</li> <li>Teams failing to comply with the rules may face disqualification.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: { name: \"Keerthana K\", phone: \"7013477128\" }\n  });\n  person1 = new Person_default({\n    props: {\n      name: \"Bavanamrutha P\",\n      phone: \"9985049999\"\n    }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let section2;\n  let t3;\n  let section3;\n  let t4;\n  let section4;\n  let t5;\n  let section5;\n  let t6;\n  let section6;\n  let t7;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_9] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"event-info\",\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  section2 = new Section_default({\n    props: {\n      name: \"general-guidelines\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  section3 = new Section_default({\n    props: {\n      name: \"performance-rules\",\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  section4 = new Section_default({\n    props: {\n      name: \"judging-criteria\",\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section5 = new Section_default({\n    props: {\n      name: \"prizes\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section6 = new Section_default({\n    props: {\n      name: \"additional-info\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(section2.$$.fragment);\n      t3 = space();\n      create_component(section3.$$.fragment);\n      t4 = space();\n      create_component(section4.$$.fragment);\n      t5 = space();\n      create_component(section5.$$.fragment);\n      t6 = space();\n      create_component(section6.$$.fragment);\n      t7 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(section2, target, anchor);\n      insert(target, t3, anchor);\n      mount_component(section3, target, anchor);\n      insert(target, t4, anchor);\n      mount_component(section4, target, anchor);\n      insert(target, t5, anchor);\n      mount_component(section5, target, anchor);\n      insert(target, t6, anchor);\n      mount_component(section6, target, anchor);\n      insert(target, t7, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const section2_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section2_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section2.$set(section2_changes);\n      const section3_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section3_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section3.$set(section3_changes);\n      const section4_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section4_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section4.$set(section4_changes);\n      const section5_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section5_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section5.$set(section5_changes);\n      const section6_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section6_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section6.$set(section6_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(section2.$$.fragment, local);\n      transition_in(section3.$$.fragment, local);\n      transition_in(section4.$$.fragment, local);\n      transition_in(section5.$$.fragment, local);\n      transition_in(section6.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(section2.$$.fragment, local);\n      transition_out(section3.$$.fragment, local);\n      transition_out(section4.$$.fragment, local);\n      transition_out(section5.$$.fragment, local);\n      transition_out(section6.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n        detach(t3);\n        detach(t4);\n        detach(t5);\n        detach(t6);\n        detach(t7);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(section2, detaching);\n      destroy_component(section3, detaching);\n      destroy_component(section4, detaching);\n      destroy_component(section5, detaching);\n      destroy_component(section6, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  }
}