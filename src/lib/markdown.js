export const events_compiledmap={
  "WP02": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WP03": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WP01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-vk2f6a\", \".main.svelte-vk2f6a{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-vk2f6a{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-vk2f6a{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-vk2f6a{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}\");\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1_value = (\n    /*personData*/\n    ctx[0].name + \"\"\n  );\n  let t1;\n  let t2;\n  let p;\n  let t3_value = (\n    /*personData*/\n    ctx[0].phone + \"\"\n  );\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(t1_value);\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(t3_value);\n      attr(div0, \"class\", \"backpic svelte-vk2f6a\");\n      set_style(div0, \"background-image\", \"url('\" + /*personData*/\n      ctx[0].image + \"')\");\n      attr(h2, \"class\", \"svelte-vk2f6a\");\n      attr(p, \"class\", \"svelte-vk2f6a\");\n      attr(div1, \"class\", \"main svelte-vk2f6a\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*personData*/\n      1) {\n        set_style(div0, \"background-image\", \"url('\" + /*personData*/\n        ctx2[0].image + \"')\");\n      }\n      if (dirty & /*personData*/\n      1 && t1_value !== (t1_value = /*personData*/\n      ctx2[0].name + \"\")) set_data(t1, t1_value);\n      if (dirty & /*personData*/\n      1 && t3_value !== (t3_value = /*personData*/\n      ctx2[0].phone + \"\")) set_data(t3, t3_value);\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { personData = {\n    name: \"John Doe\",\n    phone: \"123-456-7890\",\n    image: \"https://picsum.photos/200/300\"\n  } } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"personData\" in $$props2) $$invalidate(0, personData = $$props2.personData);\n  };\n  return [personData];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { personData: 0 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-vydx3c\", \".buttons.svelte-vydx3c.svelte-vydx3c{margin-top:2rem;margin-bottom:2rem}.buttons.svelte-vydx3c>button.svelte-vydx3c{margin-left:0.75em;margin-right:0.75em}button.svelte-vydx3c.svelte-vydx3c{border:none;background-color:transparent}.a-unset.svelte-vydx3c.svelte-vydx3c{text-decoration:none;color:white}.register.svelte-vydx3c.svelte-vydx3c{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-vydx3c.svelte-vydx3c:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-vydx3c.svelte-vydx3c{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-vydx3c.svelte-vydx3c{margin-bottom:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-vydx3c\");\n      attr(div, \"class\", \"buttons svelte-vydx3c\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Voicestra\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WF04": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-vk2f6a\", \".main.svelte-vk2f6a{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-vk2f6a{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-vk2f6a{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-vk2f6a{font-family:'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}\");\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1_value = (\n    /*personData*/\n    ctx[0].name + \"\"\n  );\n  let t1;\n  let t2;\n  let p;\n  let t3_value = (\n    /*personData*/\n    ctx[0].phone + \"\"\n  );\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(t1_value);\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(t3_value);\n      attr(div0, \"class\", \"backpic svelte-vk2f6a\");\n      set_style(div0, \"background-image\", \"url('\" + /*personData*/\n      ctx[0].image + \"')\");\n      attr(h2, \"class\", \"svelte-vk2f6a\");\n      attr(p, \"class\", \"svelte-vk2f6a\");\n      attr(div1, \"class\", \"main svelte-vk2f6a\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*personData*/\n      1) {\n        set_style(div0, \"background-image\", \"url('\" + /*personData*/\n        ctx2[0].image + \"')\");\n      }\n      if (dirty & /*personData*/\n      1 && t1_value !== (t1_value = /*personData*/\n      ctx2[0].name + \"\")) set_data(t1, t1_value);\n      if (dirty & /*personData*/\n      1 && t3_value !== (t3_value = /*personData*/\n      ctx2[0].phone + \"\")) set_data(t3, t3_value);\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { personData = {\n    name: \"John Doe\",\n    phone: \"123-456-7890\",\n    image: \"https://picsum.photos/200/300\"\n  } } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"personData\" in $$props2) $$invalidate(0, personData = $$props2.personData);\n  };\n  return [personData];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { personData: 0 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-vydx3c\", \".buttons.svelte-vydx3c.svelte-vydx3c{margin-top:2rem;margin-bottom:2rem}.buttons.svelte-vydx3c>button.svelte-vydx3c{margin-left:0.75em;margin-right:0.75em}button.svelte-vydx3c.svelte-vydx3c{border:none;background-color:transparent}.a-unset.svelte-vydx3c.svelte-vydx3c{text-decoration:none;color:white}.register.svelte-vydx3c.svelte-vydx3c{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-vydx3c.svelte-vydx3c:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-vydx3c.svelte-vydx3c{display:block;margin-bottom:1em;text-align:center}.buttons.svelte-vydx3c.svelte-vydx3c{margin-bottom:0px}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-vydx3c\");\n      attr(div, \"class\", \"buttons svelte-vydx3c\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Voicestra\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  }
}