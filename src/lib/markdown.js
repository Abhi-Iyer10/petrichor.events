export const events_compiledmap={
  "WP02": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WP03": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element, listener) {\n    this._listeners.set(element, listener);\n    this._getObserver().observe(element, this.options);\n    return () => {\n      this._listeners.delete(element);\n      this._observer.unobserve(element);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction children(element) {\n  return Array.from(element.childNodes);\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance, create_fragment, not_equal, props, append_styles, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles && append_styles($$.root);\n  let ready = false;\n  $$.ctx = instance ? instance(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment ? create_fragment($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr, _oldValue, newValue) {\n      this[attr] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./markdown.mdx\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, null, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "WF01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Voicestra\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person;\n  let current;\n  person = new Person_default({ props: { name: \"Human\", phone: \"1234\" } });\n  return {\n    c() {\n      create_component(person.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(person, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TF01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_8(ctx) {\n  let h1;\n  let t1;\n  let p;\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"This is a Section\";\n      t1 = space();\n      p = element(\"p\");\n      p.textContent = \"Use this component to group related elements.\";\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_7(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"All content here is centered!\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"This content is inside a styled box.\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let p;\n  return {\n    c() {\n      p = element(\"p\");\n      p.textContent = \"This is a nested Box!\";\n    },\n    m(target, anchor) {\n      insert(target, p, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(p);\n      }\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let box;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      destroy_component(box, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h10;\n  let t1;\n  let ul0;\n  let t16;\n  let h11;\n  let t18;\n  let p5;\n  let t22;\n  let h30;\n  let t24;\n  let person;\n  let t25;\n  let p6;\n  let t28;\n  let hr1;\n  let t29;\n  let h20;\n  let t31;\n  let h31;\n  let t33;\n  let p7;\n  let t35;\n  let p8;\n  let t37;\n  let ul1;\n  let t39;\n  let p9;\n  let t41;\n  let ol;\n  let t43;\n  let p10;\n  let t45;\n  let hr2;\n  let t46;\n  let h12;\n  let t48;\n  let h21;\n  let t50;\n  let p11;\n  let t54;\n  let h32;\n  let t56;\n  let section;\n  let t57;\n  let h22;\n  let t59;\n  let p12;\n  let t63;\n  let h33;\n  let t65;\n  let centersection;\n  let t66;\n  let hr3;\n  let t67;\n  let h23;\n  let t69;\n  let p13;\n  let t73;\n  let h34;\n  let t75;\n  let box0;\n  let t76;\n  let h35;\n  let t78;\n  let p14;\n  let t82;\n  let box1;\n  let t83;\n  let hr4;\n  let t84;\n  let h24;\n  let t86;\n  let p15;\n  let t90;\n  let h36;\n  let t92;\n  let flexsection;\n  let t93;\n  let hr5;\n  let t94;\n  let h13;\n  let t96;\n  let p16;\n  let current;\n  person = new Person_default({ props: { name: \"Human\", phone: \"1234\" } });\n  section = new Section_default({\n    props: {\n      $$slots: { default: [create_default_slot_8] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  box0 = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  box1 = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h10 = element(\"h1\");\n      h10.textContent = \"Svelte Components Tutorial\";\n      t1 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><p>This guide demonstrates how to use custom Svelte components for structuring and styling content effectively.</p></li> <li><p>Please compare the code and the corresponding result in the next window.</p></li> <li><p>If you <span style=\"color:red;margin:0px;\">do not want to go through this whole document.</span>\nYou can directly use the template.\nCreating a new Event provides you with a template just edit the details of the template.</p></li> <li><p>Feel free to come here any time to know about the components. This will help you if you want to add new Sections other than the template.\nWhatever be your choice, be sure to look at Organizer Section below.</p></li> <li><p>Be sure to keep copying this whole code  in your clipboard. If nothing renders click on <code>convert</code> button above. If still it doesn\\u2019t render, maybe there is some error in the code</p> <hr/></li>`;\n      t16 = space();\n      h11 = element(\"h1\");\n      h11.textContent = \"Organizer Example\";\n      t18 = space();\n      p5 = element(\"p\");\n      p5.innerHTML = `When defining an organizer, ensure the <code>name</code> field matches exactly as specified in your declaration. For example:`;\n      t22 = space();\n      h30 = element(\"h3\");\n      h30.textContent = \"Organizer Declaration:\";\n      t24 = space();\n      create_component(person.$$.fragment);\n      t25 = space();\n      p6 = element(\"p\");\n      p6.innerHTML = `<strong>Note:</strong> Any updates or additions to this site will not directly reflect on the main Petrichor website. A final push will be performed from our side.`;\n      t28 = space();\n      hr1 = element(\"hr\");\n      t29 = space();\n      h20 = element(\"h2\");\n      h20.textContent = \"Basic HTML Usage\";\n      t31 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Example 1: Creating Lists\";\n      t33 = space();\n      p7 = element(\"p\");\n      p7.textContent = \"You can create lists directly with HTML tags:\";\n      t35 = space();\n      p8 = element(\"p\");\n      p8.innerHTML = `<strong>Unordered List Example:</strong>`;\n      t37 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Hello</li>`;\n      t39 = space();\n      p9 = element(\"p\");\n      p9.innerHTML = `<strong>Ordered List Example:</strong>`;\n      t41 = space();\n      ol = element(\"ol\");\n      ol.innerHTML = `<li>Hello</li>`;\n      t43 = space();\n      p10 = element(\"p\");\n      p10.textContent = \"Feel free to use any HTML tags or apply custom styles as needed within your content.\";\n      t45 = space();\n      hr2 = element(\"hr\");\n      t46 = space();\n      h12 = element(\"h1\");\n      h12.textContent = \"Component Overview\";\n      t48 = space();\n      h21 = element(\"h2\");\n      h21.innerHTML = `<code>&lt;Section&gt;</code>`;\n      t50 = space();\n      p11 = element(\"p\");\n      p11.innerHTML = `The <code>&lt;Section&gt;</code> component serves as a general-purpose container for grouping related content. It can help organize your layout effectively.`;\n      t54 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Example:\";\n      t56 = space();\n      create_component(section.$$.fragment);\n      t57 = space();\n      h22 = element(\"h2\");\n      h22.innerHTML = `<code>&lt;CenterSection&gt;</code>`;\n      t59 = space();\n      p12 = element(\"p\");\n      p12.innerHTML = `The <code>&lt;CenterSection&gt;</code> component centers all its child content, making it ideal for focus areas.`;\n      t63 = space();\n      h33 = element(\"h3\");\n      h33.textContent = \"Example:\";\n      t65 = space();\n      create_component(centersection.$$.fragment);\n      t66 = space();\n      hr3 = element(\"hr\");\n      t67 = space();\n      h23 = element(\"h2\");\n      h23.innerHTML = `<code>&lt;Box&gt;</code>`;\n      t69 = space();\n      p13 = element(\"p\");\n      p13.innerHTML = `The <code>&lt;Box&gt;</code> component wraps its child elements inside a styled container, adding a visually distinct boundary.`;\n      t73 = space();\n      h34 = element(\"h3\");\n      h34.textContent = \"Example:\";\n      t75 = space();\n      create_component(box0.$$.fragment);\n      t76 = space();\n      h35 = element(\"h3\");\n      h35.textContent = \"Nested Components:\";\n      t78 = space();\n      p14 = element(\"p\");\n      p14.innerHTML = `You can nest components inside <code>&lt;Box&gt;</code> for more complex layouts:`;\n      t82 = space();\n      create_component(box1.$$.fragment);\n      t83 = space();\n      hr4 = element(\"hr\");\n      t84 = space();\n      h24 = element(\"h2\");\n      h24.innerHTML = `<code>&lt;FlexSection&gt;</code>`;\n      t86 = space();\n      p15 = element(\"p\");\n      p15.innerHTML = `The <code>&lt;FlexSection&gt;</code> component is ideal for creating flexible layouts using a row or column-based structure.`;\n      t90 = space();\n      h36 = element(\"h3\");\n      h36.textContent = \"Example:\";\n      t92 = space();\n      create_component(flexsection.$$.fragment);\n      t93 = space();\n      hr5 = element(\"hr\");\n      t94 = space();\n      h13 = element(\"h1\");\n      h13.textContent = \"Tutorial\";\n      t96 = space();\n      p16 = element(\"p\");\n      p16.innerHTML = `Follow the tutorial steps provided in the <code>tutorial_event</code>.`;\n    },\n    m(target, anchor) {\n      insert(target, h10, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t16, anchor);\n      insert(target, h11, anchor);\n      insert(target, t18, anchor);\n      insert(target, p5, anchor);\n      insert(target, t22, anchor);\n      insert(target, h30, anchor);\n      insert(target, t24, anchor);\n      mount_component(person, target, anchor);\n      insert(target, t25, anchor);\n      insert(target, p6, anchor);\n      insert(target, t28, anchor);\n      insert(target, hr1, anchor);\n      insert(target, t29, anchor);\n      insert(target, h20, anchor);\n      insert(target, t31, anchor);\n      insert(target, h31, anchor);\n      insert(target, t33, anchor);\n      insert(target, p7, anchor);\n      insert(target, t35, anchor);\n      insert(target, p8, anchor);\n      insert(target, t37, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t39, anchor);\n      insert(target, p9, anchor);\n      insert(target, t41, anchor);\n      insert(target, ol, anchor);\n      insert(target, t43, anchor);\n      insert(target, p10, anchor);\n      insert(target, t45, anchor);\n      insert(target, hr2, anchor);\n      insert(target, t46, anchor);\n      insert(target, h12, anchor);\n      insert(target, t48, anchor);\n      insert(target, h21, anchor);\n      insert(target, t50, anchor);\n      insert(target, p11, anchor);\n      insert(target, t54, anchor);\n      insert(target, h32, anchor);\n      insert(target, t56, anchor);\n      mount_component(section, target, anchor);\n      insert(target, t57, anchor);\n      insert(target, h22, anchor);\n      insert(target, t59, anchor);\n      insert(target, p12, anchor);\n      insert(target, t63, anchor);\n      insert(target, h33, anchor);\n      insert(target, t65, anchor);\n      mount_component(centersection, target, anchor);\n      insert(target, t66, anchor);\n      insert(target, hr3, anchor);\n      insert(target, t67, anchor);\n      insert(target, h23, anchor);\n      insert(target, t69, anchor);\n      insert(target, p13, anchor);\n      insert(target, t73, anchor);\n      insert(target, h34, anchor);\n      insert(target, t75, anchor);\n      mount_component(box0, target, anchor);\n      insert(target, t76, anchor);\n      insert(target, h35, anchor);\n      insert(target, t78, anchor);\n      insert(target, p14, anchor);\n      insert(target, t82, anchor);\n      mount_component(box1, target, anchor);\n      insert(target, t83, anchor);\n      insert(target, hr4, anchor);\n      insert(target, t84, anchor);\n      insert(target, h24, anchor);\n      insert(target, t86, anchor);\n      insert(target, p15, anchor);\n      insert(target, t90, anchor);\n      insert(target, h36, anchor);\n      insert(target, t92, anchor);\n      mount_component(flexsection, target, anchor);\n      insert(target, t93, anchor);\n      insert(target, hr5, anchor);\n      insert(target, t94, anchor);\n      insert(target, h13, anchor);\n      insert(target, t96, anchor);\n      insert(target, p16, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n      const box0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box0.$set(box0_changes);\n      const box1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box1.$set(box1_changes);\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person.$$.fragment, local);\n      transition_in(section.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      transition_in(box0.$$.fragment, local);\n      transition_in(box1.$$.fragment, local);\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person.$$.fragment, local);\n      transition_out(section.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      transition_out(box0.$$.fragment, local);\n      transition_out(box1.$$.fragment, local);\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h10);\n        detach(t1);\n        detach(ul0);\n        detach(t16);\n        detach(h11);\n        detach(t18);\n        detach(p5);\n        detach(t22);\n        detach(h30);\n        detach(t24);\n        detach(t25);\n        detach(p6);\n        detach(t28);\n        detach(hr1);\n        detach(t29);\n        detach(h20);\n        detach(t31);\n        detach(h31);\n        detach(t33);\n        detach(p7);\n        detach(t35);\n        detach(p8);\n        detach(t37);\n        detach(ul1);\n        detach(t39);\n        detach(p9);\n        detach(t41);\n        detach(ol);\n        detach(t43);\n        detach(p10);\n        detach(t45);\n        detach(hr2);\n        detach(t46);\n        detach(h12);\n        detach(t48);\n        detach(h21);\n        detach(t50);\n        detach(p11);\n        detach(t54);\n        detach(h32);\n        detach(t56);\n        detach(t57);\n        detach(h22);\n        detach(t59);\n        detach(p12);\n        detach(t63);\n        detach(h33);\n        detach(t65);\n        detach(t66);\n        detach(hr3);\n        detach(t67);\n        detach(h23);\n        detach(t69);\n        detach(p13);\n        detach(t73);\n        detach(h34);\n        detach(t75);\n        detach(t76);\n        detach(h35);\n        detach(t78);\n        detach(p14);\n        detach(t82);\n        detach(t83);\n        detach(hr4);\n        detach(t84);\n        detach(h24);\n        detach(t86);\n        detach(p15);\n        detach(t90);\n        detach(h36);\n        detach(t92);\n        detach(t93);\n        detach(hr5);\n        detach(t94);\n        detach(h13);\n        detach(t96);\n        detach(p16);\n      }\n      destroy_component(person, detaching);\n      destroy_component(section, detaching);\n      destroy_component(centersection, detaching);\n      destroy_component(box0, detaching);\n      destroy_component(box1, detaching);\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let section;\n  let t0;\n  let p0;\n  let t3;\n  let hr;\n  let t4;\n  let h1;\n  let t6;\n  let p1;\n  let t10;\n  let p2;\n  let current;\n  section = new Section_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(section.$$.fragment);\n      t0 = space();\n      p0 = element(\"p\");\n      p0.innerHTML = `<strong>Note:</strong> Any updates or additions to this site will not directly reflect on the main Petrichor website. A final push will be performed from our side.`;\n      t3 = space();\n      hr = element(\"hr\");\n      t4 = space();\n      h1 = element(\"h1\");\n      h1.textContent = \"Markdown Template for Events\";\n      t6 = space();\n      p1 = element(\"p\");\n      p1.innerHTML = `When you press <code>AddEvent</code> on the previous page, a template markdown will be generated. You can either edit it or add new content to suit your requirements.`;\n      t10 = space();\n      p2 = element(\"p\");\n      p2.textContent = \"Feel free to explore the flexibility of these components to enhance your application!\";\n    },\n    m(target, anchor) {\n      mount_component(section, target, anchor);\n      insert(target, t0, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, hr, anchor);\n      insert(target, t4, anchor);\n      insert(target, h1, anchor);\n      insert(target, t6, anchor);\n      insert(target, p1, anchor);\n      insert(target, t10, anchor);\n      insert(target, p2, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const section_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section.$set(section_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(section.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(section.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(p0);\n        detach(t3);\n        detach(hr);\n        detach(t4);\n        detach(h1);\n        detach(t6);\n        detach(p1);\n        detach(t10);\n        detach(p2);\n      }\n      destroy_component(section, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TF03": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"test event 2(free)\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TP02": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Test Event 1 (Paid)\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "CP01": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Test Event 1(Paid)\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"27-09-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Join our solo singing competition, welcoming voices from East and West,\\nspanning every genre! Elevate your voice, captivate the audience, and\\nlet the world be spellbound by your talent. It\\u2019s your moment to enchant\\nand leave everyone breathless, no matter the genre or cultural influence\\nevery style is welcome.\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Structure\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>Participants must finish the painting within 60 minutes.</li> <li>The theme will be announced before the event.</li> <li>Participants are supposed to bring the necessary brushes, sponges and mixing trays.</li> <li>Paints will be provided.</li> <li>No part of the design may be applied to the models face before the start of the event.</li> <li>Painting must not extend down the neck or onto the models chest, shoulders or back areas.</li> <li>Hair may be clipped or pinned back to fully expose the design area.</li> <li>Participants should respect the time limit and not disrupt other contestants.</li> <li>Any inappropriate or offensive designs will result in disqualification.</li> <li>Decision made by the judges are final. Requests to reconsider the final decision would not be entertained.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({});\n  person1 = new Person_default({});\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  },
  "TF04": {
    "data": "// cdn:https://cdn.jsdelivr.net/npm/svelte/internal/index.mjs\nfunction noop() {\n}\nfunction assign(tar, src) {\n  for (const k in src)\n    tar[k] = src[k];\n  return tar;\n}\nfunction run(fn) {\n  return fn();\n}\nfunction blank_object() {\n  return /* @__PURE__ */ Object.create(null);\n}\nfunction run_all(fns) {\n  fns.forEach(run);\n}\nfunction is_function(thing) {\n  return typeof thing === \"function\";\n}\nfunction safe_not_equal(a, b) {\n  return a != a ? b == b : a !== b || (a && typeof a === \"object\" || typeof a === \"function\");\n}\nfunction is_empty(obj) {\n  return Object.keys(obj).length === 0;\n}\nfunction create_slot(definition, ctx, $$scope, fn) {\n  if (definition) {\n    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);\n    return definition[0](slot_ctx);\n  }\n}\nfunction get_slot_context(definition, ctx, $$scope, fn) {\n  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;\n}\nfunction get_slot_changes(definition, $$scope, dirty, fn) {\n  if (definition[2] && fn) {\n    const lets = definition[2](fn(dirty));\n    if ($$scope.dirty === void 0) {\n      return lets;\n    }\n    if (typeof lets === \"object\") {\n      const merged = [];\n      const len = Math.max($$scope.dirty.length, lets.length);\n      for (let i = 0; i < len; i += 1) {\n        merged[i] = $$scope.dirty[i] | lets[i];\n      }\n      return merged;\n    }\n    return $$scope.dirty | lets;\n  }\n  return $$scope.dirty;\n}\nfunction update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {\n  if (slot_changes) {\n    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);\n    slot.p(slot_context, slot_changes);\n  }\n}\nfunction get_all_dirty_from_scope($$scope) {\n  if ($$scope.ctx.length > 32) {\n    const dirty = [];\n    const length = $$scope.ctx.length / 32;\n    for (let i = 0; i < length; i++) {\n      dirty[i] = -1;\n    }\n    return dirty;\n  }\n  return -1;\n}\nvar globals = typeof window !== \"undefined\" ? window : typeof globalThis !== \"undefined\" ? globalThis : global;\nvar ResizeObserverSingleton = class _ResizeObserverSingleton {\n  constructor(options) {\n    this.options = options;\n    this._listeners = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\n  }\n  observe(element2, listener) {\n    this._listeners.set(element2, listener);\n    this._getObserver().observe(element2, this.options);\n    return () => {\n      this._listeners.delete(element2);\n      this._observer.unobserve(element2);\n    };\n  }\n  _getObserver() {\n    var _a;\n    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {\n      var _a2;\n      for (const entry of entries) {\n        _ResizeObserverSingleton.entries.set(entry.target, entry);\n        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);\n      }\n    });\n  }\n};\nResizeObserverSingleton.entries = \"WeakMap\" in globals ? /* @__PURE__ */ new WeakMap() : void 0;\nvar is_hydrating = false;\nfunction start_hydrating() {\n  is_hydrating = true;\n}\nfunction end_hydrating() {\n  is_hydrating = false;\n}\nfunction append(target, node) {\n  target.appendChild(node);\n}\nfunction append_styles(target, style_sheet_id, styles) {\n  const append_styles_to = get_root_for_style(target);\n  if (!append_styles_to.getElementById(style_sheet_id)) {\n    const style = element(\"style\");\n    style.id = style_sheet_id;\n    style.textContent = styles;\n    append_stylesheet(append_styles_to, style);\n  }\n}\nfunction get_root_for_style(node) {\n  if (!node)\n    return document;\n  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;\n  if (root && root.host) {\n    return root;\n  }\n  return node.ownerDocument;\n}\nfunction append_stylesheet(node, style) {\n  append(node.head || node, style);\n  return style.sheet;\n}\nfunction insert(target, node, anchor) {\n  target.insertBefore(node, anchor || null);\n}\nfunction detach(node) {\n  if (node.parentNode) {\n    node.parentNode.removeChild(node);\n  }\n}\nfunction element(name) {\n  return document.createElement(name);\n}\nfunction text(data) {\n  return document.createTextNode(data);\n}\nfunction space() {\n  return text(\" \");\n}\nfunction listen(node, event, handler, options) {\n  node.addEventListener(event, handler, options);\n  return () => node.removeEventListener(event, handler, options);\n}\nfunction attr(node, attribute, value) {\n  if (value == null)\n    node.removeAttribute(attribute);\n  else if (node.getAttribute(attribute) !== value)\n    node.setAttribute(attribute, value);\n}\nfunction children(element2) {\n  return Array.from(element2.childNodes);\n}\nfunction set_data(text2, data) {\n  data = \"\" + data;\n  if (text2.data === data)\n    return;\n  text2.data = data;\n}\nfunction set_style(node, key, value, important) {\n  if (value == null) {\n    node.style.removeProperty(key);\n  } else {\n    node.style.setProperty(key, value, important ? \"important\" : \"\");\n  }\n}\nvar current_component;\nfunction set_current_component(component) {\n  current_component = component;\n}\nfunction get_current_component() {\n  if (!current_component)\n    throw new Error(\"Function called outside component initialization\");\n  return current_component;\n}\nfunction onMount(fn) {\n  get_current_component().$$.on_mount.push(fn);\n}\nvar dirty_components = [];\nvar binding_callbacks = [];\nvar render_callbacks = [];\nvar flush_callbacks = [];\nvar resolved_promise = /* @__PURE__ */ Promise.resolve();\nvar update_scheduled = false;\nfunction schedule_update() {\n  if (!update_scheduled) {\n    update_scheduled = true;\n    resolved_promise.then(flush);\n  }\n}\nfunction add_render_callback(fn) {\n  render_callbacks.push(fn);\n}\nvar seen_callbacks = /* @__PURE__ */ new Set();\nvar flushidx = 0;\nfunction flush() {\n  if (flushidx !== 0) {\n    return;\n  }\n  const saved_component = current_component;\n  do {\n    try {\n      while (flushidx < dirty_components.length) {\n        const component = dirty_components[flushidx];\n        flushidx++;\n        set_current_component(component);\n        update(component.$$);\n      }\n    } catch (e) {\n      dirty_components.length = 0;\n      flushidx = 0;\n      throw e;\n    }\n    set_current_component(null);\n    dirty_components.length = 0;\n    flushidx = 0;\n    while (binding_callbacks.length)\n      binding_callbacks.pop()();\n    for (let i = 0; i < render_callbacks.length; i += 1) {\n      const callback = render_callbacks[i];\n      if (!seen_callbacks.has(callback)) {\n        seen_callbacks.add(callback);\n        callback();\n      }\n    }\n    render_callbacks.length = 0;\n  } while (dirty_components.length);\n  while (flush_callbacks.length) {\n    flush_callbacks.pop()();\n  }\n  update_scheduled = false;\n  seen_callbacks.clear();\n  set_current_component(saved_component);\n}\nfunction update($$) {\n  if ($$.fragment !== null) {\n    $$.update();\n    run_all($$.before_update);\n    const dirty = $$.dirty;\n    $$.dirty = [-1];\n    $$.fragment && $$.fragment.p($$.ctx, dirty);\n    $$.after_update.forEach(add_render_callback);\n  }\n}\nfunction flush_render_callbacks(fns) {\n  const filtered = [];\n  const targets = [];\n  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));\n  targets.forEach((c) => c());\n  render_callbacks = filtered;\n}\nvar outroing = /* @__PURE__ */ new Set();\nvar outros;\nfunction transition_in(block, local) {\n  if (block && block.i) {\n    outroing.delete(block);\n    block.i(local);\n  }\n}\nfunction transition_out(block, local, detach2, callback) {\n  if (block && block.o) {\n    if (outroing.has(block))\n      return;\n    outroing.add(block);\n    outros.c.push(() => {\n      outroing.delete(block);\n      if (callback) {\n        if (detach2)\n          block.d(1);\n        callback();\n      }\n    });\n    block.o(local);\n  } else if (callback) {\n    callback();\n  }\n}\nvar _boolean_attributes = [\n  \"allowfullscreen\",\n  \"allowpaymentrequest\",\n  \"async\",\n  \"autofocus\",\n  \"autoplay\",\n  \"checked\",\n  \"controls\",\n  \"default\",\n  \"defer\",\n  \"disabled\",\n  \"formnovalidate\",\n  \"hidden\",\n  \"inert\",\n  \"ismap\",\n  \"loop\",\n  \"multiple\",\n  \"muted\",\n  \"nomodule\",\n  \"novalidate\",\n  \"open\",\n  \"playsinline\",\n  \"readonly\",\n  \"required\",\n  \"reversed\",\n  \"selected\"\n];\nvar boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);\nfunction create_component(block) {\n  block && block.c();\n}\nfunction mount_component(component, target, anchor, customElement) {\n  const { fragment, after_update } = component.$$;\n  fragment && fragment.m(target, anchor);\n  if (!customElement) {\n    add_render_callback(() => {\n      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);\n      if (component.$$.on_destroy) {\n        component.$$.on_destroy.push(...new_on_destroy);\n      } else {\n        run_all(new_on_destroy);\n      }\n      component.$$.on_mount = [];\n    });\n  }\n  after_update.forEach(add_render_callback);\n}\nfunction destroy_component(component, detaching) {\n  const $$ = component.$$;\n  if ($$.fragment !== null) {\n    flush_render_callbacks($$.after_update);\n    run_all($$.on_destroy);\n    $$.fragment && $$.fragment.d(detaching);\n    $$.on_destroy = $$.fragment = null;\n    $$.ctx = [];\n  }\n}\nfunction make_dirty(component, i) {\n  if (component.$$.dirty[0] === -1) {\n    dirty_components.push(component);\n    schedule_update();\n    component.$$.dirty.fill(0);\n  }\n  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;\n}\nfunction init(component, options, instance7, create_fragment8, not_equal, props, append_styles2, dirty = [-1]) {\n  const parent_component = current_component;\n  set_current_component(component);\n  const $$ = component.$$ = {\n    fragment: null,\n    ctx: [],\n    // state\n    props,\n    update: noop,\n    not_equal,\n    bound: blank_object(),\n    // lifecycle\n    on_mount: [],\n    on_destroy: [],\n    on_disconnect: [],\n    before_update: [],\n    after_update: [],\n    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),\n    // everything else\n    callbacks: blank_object(),\n    dirty,\n    skip_bound: false,\n    root: options.target || parent_component.$$.root\n  };\n  append_styles2 && append_styles2($$.root);\n  let ready = false;\n  $$.ctx = instance7 ? instance7(component, options.props || {}, (i, ret, ...rest) => {\n    const value = rest.length ? rest[0] : ret;\n    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {\n      if (!$$.skip_bound && $$.bound[i])\n        $$.bound[i](value);\n      if (ready)\n        make_dirty(component, i);\n    }\n    return ret;\n  }) : [];\n  $$.update();\n  ready = true;\n  run_all($$.before_update);\n  $$.fragment = create_fragment8 ? create_fragment8($$.ctx) : false;\n  if (options.target) {\n    if (options.hydrate) {\n      start_hydrating();\n      const nodes = children(options.target);\n      $$.fragment && $$.fragment.l(nodes);\n      nodes.forEach(detach);\n    } else {\n      $$.fragment && $$.fragment.c();\n    }\n    if (options.intro)\n      transition_in(component.$$.fragment);\n    mount_component(component, options.target, options.anchor, options.customElement);\n    end_hydrating();\n    flush();\n  }\n  set_current_component(parent_component);\n}\nvar SvelteElement;\nif (typeof HTMLElement === \"function\") {\n  SvelteElement = class extends HTMLElement {\n    constructor() {\n      super();\n      this.attachShadow({ mode: \"open\" });\n    }\n    connectedCallback() {\n      const { on_mount } = this.$$;\n      this.$$.on_disconnect = on_mount.map(run).filter(is_function);\n      for (const key in this.$$.slotted) {\n        this.appendChild(this.$$.slotted[key]);\n      }\n    }\n    attributeChangedCallback(attr2, _oldValue, newValue) {\n      this[attr2] = newValue;\n    }\n    disconnectedCallback() {\n      run_all(this.$$.on_disconnect);\n    }\n    $destroy() {\n      destroy_component(this, 1);\n      this.$destroy = noop;\n    }\n    $on(type, callback) {\n      if (!is_function(callback)) {\n        return noop;\n      }\n      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n      callbacks.push(callback);\n      return () => {\n        const index = callbacks.indexOf(callback);\n        if (index !== -1)\n          callbacks.splice(index, 1);\n      };\n    }\n    $set($$props) {\n      if (this.$$set && !is_empty($$props)) {\n        this.$$.skip_bound = true;\n        this.$$set($$props);\n        this.$$.skip_bound = false;\n      }\n    }\n  };\n}\nvar SvelteComponent = class {\n  $destroy() {\n    destroy_component(this, 1);\n    this.$destroy = noop;\n  }\n  $on(type, callback) {\n    if (!is_function(callback)) {\n      return noop;\n    }\n    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);\n    callbacks.push(callback);\n    return () => {\n      const index = callbacks.indexOf(callback);\n      if (index !== -1)\n        callbacks.splice(index, 1);\n    };\n  }\n  $set($$props) {\n    if (this.$$set && !is_empty($$props)) {\n      this.$$.skip_bound = true;\n      this.$$set($$props);\n      this.$$.skip_bound = false;\n    }\n  }\n};\n\n// components:./Box.svelte\nfunction add_css(target) {\n  append_styles(target, \"svelte-1ebm2tk\", \"div.svelte-1ebm2tk{display:flex;flex-direction:column;width:85%;place-items:center;background-color:rgba(0, 0, 0, 0.146);backdrop-filter:blur(100px);background-size:150% 150%;padding:1rem;border-radius:12px;margin-top:1em}\");\n}\nfunction create_fragment(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-1ebm2tk\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance, create_fragment, safe_not_equal, {}, add_css);\n  }\n};\nvar Box_default = Component;\n\n// components:./Person.svelte\nfunction add_css2(target) {\n  append_styles(target, \"svelte-1yc6mxu\", '.main.svelte-1yc6mxu{background-color:rgb(27, 27, 27, 0.5);backdrop-filter:blur(12px);font-family:var(--pfont);width:min-content;margin:1em;border-radius:1em;overflow:hidden;width:14em}.backpic.svelte-1yc6mxu{background-size:cover;background-position:center;position:relative;height:12em;width:12em;border-radius:0.4em;margin:1rem;background-repeat:no-repeat}h2.svelte-1yc6mxu{font-family:var(--pfont);margin-left:1rem;width:max-content}p.svelte-1yc6mxu{font-family:\"Segoe UI\", Tahoma, Geneva, Verdana, sans-serif;letter-spacing:0.05em;margin:1rem;margin-top:-0.5rem;overflow:hidden;width:fit-content;text-align:center;border-radius:0 0 0.4em 0.4em}');\n}\nfunction create_fragment2(ctx) {\n  let div1;\n  let div0;\n  let t0;\n  let h2;\n  let t1;\n  let t2;\n  let p;\n  let t3;\n  return {\n    c() {\n      div1 = element(\"div\");\n      div0 = element(\"div\");\n      t0 = space();\n      h2 = element(\"h2\");\n      t1 = text(\n        /*name*/\n        ctx[0]\n      );\n      t2 = space();\n      p = element(\"p\");\n      t3 = text(\n        /*phone*/\n        ctx[1]\n      );\n      attr(div0, \"class\", \"backpic svelte-1yc6mxu\");\n      attr(div0, \"id\", \"back_bg\");\n      set_style(div0, \"background-image\", \"url('\" + /*url*/\n      ctx[2] + \"')\");\n      attr(h2, \"class\", \"svelte-1yc6mxu\");\n      attr(p, \"class\", \"svelte-1yc6mxu\");\n      attr(div1, \"class\", \"main svelte-1yc6mxu\");\n    },\n    m(target, anchor) {\n      insert(target, div1, anchor);\n      append(div1, div0);\n      append(div1, t0);\n      append(div1, h2);\n      append(h2, t1);\n      append(div1, t2);\n      append(div1, p);\n      append(p, t3);\n    },\n    p(ctx2, [dirty]) {\n      if (dirty & /*url*/\n      4) {\n        set_style(div0, \"background-image\", \"url('\" + /*url*/\n        ctx2[2] + \"')\");\n      }\n      if (dirty & /*name*/\n      1) set_data(\n        t1,\n        /*name*/\n        ctx2[0]\n      );\n      if (dirty & /*phone*/\n      2) set_data(\n        t3,\n        /*phone*/\n        ctx2[1]\n      );\n    },\n    i: noop,\n    o: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(div1);\n      }\n    }\n  };\n}\nfunction instance2($$self, $$props, $$invalidate) {\n  let { name = \"John Doe\" } = $$props;\n  let { phone = \"123-456-7890\" } = $$props;\n  let url = \"https://www.svgrepo.com/download/454078/account.svg\";\n  let origin = \"https://finance-petrichor.vercel.app\";\n  onMount(async () => {\n    if (window.top.location.origin) origin = window.top.location.origin;\n    if (phone != \"123-456-7890\") {\n      console.log(\"Origin:\", origin), process.env.pass;\n      if (origin == \"https://finance-petrichor.vercel.app\" || origin == \"http://localhost:5173\") {\n        console.log(\"Fetching image\", origin);\n        await fetch(\"https://petri-back.vercel.app/internal/image/\", {\n          method: \"POST\",\n          headers: { \"Content-type\": \"application/json\" },\n          credentials: \"include\",\n          mode: \"cors\",\n          body: JSON.stringify({ name })\n        }).then((res) => res.json()).then((res) => {\n          console.log(\"Got Image\");\n          const imageURL = `data:image/png;base64,${res.image}`;\n          $$invalidate(2, url = `${imageURL}`);\n        }).catch((err) => {\n          console.log(\"image fetch error: \", err.toString());\n        });\n      } else {\n        $$invalidate(2, url = `${origin}/uploads/${name.toLowerCase()}.png`);\n      }\n    } else {\n      $$invalidate(2, url = \"https://picsum.photos/200/300\");\n    }\n  });\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"phone\" in $$props2) $$invalidate(1, phone = $$props2.phone);\n  };\n  return [name, phone, url];\n}\nvar Component2 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance2, create_fragment2, safe_not_equal, { name: 0, phone: 1 }, add_css2);\n  }\n};\nvar Person_default = Component2;\n\n// components:./FlexSection.svelte\nfunction add_css3(target) {\n  append_styles(target, \"svelte-d8w8w0\", \"div.svelte-d8w8w0{display:flex;justify-content:center;flex-wrap:wrap}\");\n}\nfunction create_fragment3(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[1].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[0],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(div, \"class\", \"svelte-d8w8w0\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        1)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[0],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[0]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[0],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance3($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"$$scope\" in $$props2) $$invalidate(0, $$scope = $$props2.$$scope);\n  };\n  return [$$scope, slots];\n}\nvar Component3 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance3, create_fragment3, safe_not_equal, {}, add_css3);\n  }\n};\nvar FlexSection_default = Component3;\n\n// components:./CenterSection.svelte\nfunction add_css4(target) {\n  append_styles(target, \"svelte-195uwti\", \"div.svelte-195uwti{display:flex;flex-direction:column;align-items:center}\");\n}\nfunction create_fragment4(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-195uwti\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance4($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component4 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance4, create_fragment4, safe_not_equal, { name: 0 }, add_css4);\n  }\n};\nvar CenterSection_default = Component4;\n\n// components:./Section.svelte\nfunction add_css5(target) {\n  append_styles(target, \"svelte-1opnu7p\", \"div.svelte-1opnu7p{width:90%;border-radius:10px;margin:10px;padding:10px;font-size:22px}@media(max-width: 600px){div.svelte-1opnu7p{font-size:17px;padding:0px;margin:0px}}\");\n}\nfunction create_fragment5(ctx) {\n  let div;\n  let current;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[2].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[1],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      if (default_slot) default_slot.c();\n      attr(\n        div,\n        \"id\",\n        /*name*/\n        ctx[0]\n      );\n      attr(div, \"class\", \"svelte-1opnu7p\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      if (default_slot) {\n        default_slot.m(div, null);\n      }\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        2)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[1],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[1]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[1],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n      if (!current || dirty & /*name*/\n      1) {\n        attr(\n          div,\n          \"id\",\n          /*name*/\n          ctx2[0]\n        );\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n    }\n  };\n}\nfunction instance5($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { name } = $$props;\n  $$self.$$set = ($$props2) => {\n    if (\"name\" in $$props2) $$invalidate(0, name = $$props2.name);\n    if (\"$$scope\" in $$props2) $$invalidate(1, $$scope = $$props2.$$scope);\n  };\n  return [name, $$scope, slots];\n}\nvar Component5 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance5, create_fragment5, safe_not_equal, { name: 0 }, add_css5);\n  }\n};\nvar Section_default = Component5;\n\n// components:./Button.svelte\nfunction add_css6(target) {\n  append_styles(target, \"svelte-1hzyij5\", \".buttons.svelte-1hzyij5{margin-top:2rem;margin-bottom:2rem}button.svelte-1hzyij5{border:none;background-color:transparent}.a-unset.svelte-1hzyij5{text-decoration:none;color:white}.register.svelte-1hzyij5{padding:0.8em;padding-inline:1em;background-color:rgba(237, 237, 237, 0.137);border-radius:0.4em;margin:0 10px;border:unset;color:white;font-size:20px;transition:200ms ease-in-out}.register.svelte-1hzyij5:hover{background-color:rgb(255, 255, 255);color:black}@media(max-width: 600px){.register.svelte-1hzyij5{display:block;margin-bottom:1em;text-align:center}}\");\n}\nfunction create_fragment6(ctx) {\n  let div;\n  let button;\n  let current;\n  let mounted;\n  let dispose;\n  const default_slot_template = (\n    /*#slots*/\n    ctx[3].default\n  );\n  const default_slot = create_slot(\n    default_slot_template,\n    ctx,\n    /*$$scope*/\n    ctx[2],\n    null\n  );\n  return {\n    c() {\n      div = element(\"div\");\n      button = element(\"button\");\n      if (default_slot) default_slot.c();\n      attr(button, \"class\", \"a-unset register svelte-1hzyij5\");\n      attr(div, \"class\", \"buttons svelte-1hzyij5\");\n    },\n    m(target, anchor) {\n      insert(target, div, anchor);\n      append(div, button);\n      if (default_slot) {\n        default_slot.m(button, null);\n      }\n      current = true;\n      if (!mounted) {\n        dispose = listen(\n          button,\n          \"click\",\n          /*handleClick*/\n          ctx[0]\n        );\n        mounted = true;\n      }\n    },\n    p(ctx2, [dirty]) {\n      if (default_slot) {\n        if (default_slot.p && (!current || dirty & /*$$scope*/\n        4)) {\n          update_slot_base(\n            default_slot,\n            default_slot_template,\n            ctx2,\n            /*$$scope*/\n            ctx2[2],\n            !current ? get_all_dirty_from_scope(\n              /*$$scope*/\n              ctx2[2]\n            ) : get_slot_changes(\n              default_slot_template,\n              /*$$scope*/\n              ctx2[2],\n              dirty,\n              null\n            ),\n            null\n          );\n        }\n      }\n    },\n    i(local) {\n      if (current) return;\n      transition_in(default_slot, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(default_slot, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(div);\n      }\n      if (default_slot) default_slot.d(detaching);\n      mounted = false;\n      dispose();\n    }\n  };\n}\nfunction instance6($$self, $$props, $$invalidate) {\n  let { $$slots: slots = {}, $$scope } = $$props;\n  let { url = \"#rules\" } = $$props;\n  let origin = \"\";\n  onMount(() => {\n    origin = window.top?.location.url;\n  });\n  function handleClick() {\n    if (url.startsWith(\"#\")) {\n      const rulesElement = document.getElementById(url.replace(\"#\", \"\"));\n      if (rulesElement) {\n        rulesElement.scrollIntoView({ behavior: \"smooth\" });\n        rulesElement.focus();\n      }\n    } else if (url == \"register\") {\n      window.top.location.href = `${origin}/#register`;\n    } else {\n      window.top.location.href = url;\n    }\n  }\n  $$self.$$set = ($$props2) => {\n    if (\"url\" in $$props2) $$invalidate(1, url = $$props2.url);\n    if (\"$$scope\" in $$props2) $$invalidate(2, $$scope = $$props2.$$scope);\n  };\n  return [handleClick, url, $$scope, slots];\n}\nvar Component6 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, instance6, create_fragment6, safe_not_equal, { url: 1 }, add_css6);\n  }\n};\nvar Button_default = Component6;\n\n// components:./markdown.mdx\nfunction create_default_slot_7(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Learn More\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_6(ctx) {\n  let t;\n  return {\n    c() {\n      t = text(\"Register\");\n    },\n    m(target, anchor) {\n      insert(target, t, anchor);\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n    }\n  };\n}\nfunction create_default_slot_5(ctx) {\n  let button0;\n  let t;\n  let button1;\n  let current;\n  button0 = new Button_default({\n    props: {\n      url: \"#rules\",\n      $$slots: { default: [create_default_slot_7] },\n      $$scope: { ctx }\n    }\n  });\n  button1 = new Button_default({\n    props: {\n      url: \"#register\",\n      $$slots: { default: [create_default_slot_6] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(button0.$$.fragment);\n      t = space();\n      create_component(button1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(button0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(button1, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const button0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button0.$set(button0_changes);\n      const button1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        button1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      button1.$set(button1_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(button0.$$.fragment, local);\n      transition_in(button1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(button0.$$.fragment, local);\n      transition_out(button1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(button0, detaching);\n      destroy_component(button1, detaching);\n    }\n  };\n}\nfunction create_default_slot_4(ctx) {\n  let h1;\n  let t1;\n  let p0;\n  let t3;\n  let p1;\n  let t5;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_5] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Capture the Flag\";\n      t1 = space();\n      p0 = element(\"p\");\n      p0.textContent = \"12-01-2025\";\n      t3 = space();\n      p1 = element(\"p\");\n      p1.textContent = \"Cipherify is a thrilling Capture the Flag (CTF) event where the participants are expected to showcase their cybersecurity, problem-solving, and hacking skills in a competitive and time-sensitive environment. Whether you are a beginner or an experienced elite, the event will feature challenges across categories like cryptography, reverse engineering, web exploitation, forensics, and more. The goal is simple: get the flag, find the hidden \\u201Cflags,\\u201D and earn points to climb the leaderboard.\\nThis 6-hour-long competition will challenge your technical expertise, analytical thinking, and teamwork. Whether you\\u2019re a solo player or part of a team, Cipherify promises a unique experience. Get ready to capture the flag!\";\n      t5 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      insert(target, p0, anchor);\n      insert(target, t3, anchor);\n      insert(target, p1, anchor);\n      insert(target, t5, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n        detach(p0);\n        detach(t3);\n        detach(p1);\n        detach(t5);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_default_slot_3(ctx) {\n  let h3;\n  let t1;\n  let ul;\n  return {\n    c() {\n      h3 = element(\"h3\");\n      h3.textContent = \"Rules\";\n      t1 = space();\n      ul = element(\"ul\");\n      ul.innerHTML = `<li>The CTF will be jeopardy-style (please Google it if you are new to this).</li> <li>Sharing of flags with other teams is not allowed.</li> <li>In case of any discrepancy, the decision of the event coordinators will be considered final.</li> <li>The platform for the CTF and the credentials will be mailed to the registered participants a week before the event.</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h3, anchor);\n      insert(target, t1, anchor);\n      insert(target, ul, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h3);\n        detach(t1);\n        detach(ul);\n      }\n    }\n  };\n}\nfunction create_default_slot_2(ctx) {\n  let h30;\n  let t1;\n  let h40;\n  let t3;\n  let ul0;\n  let t12;\n  let h41;\n  let t14;\n  let ul1;\n  let t16;\n  let h31;\n  let t18;\n  let ul2;\n  let t27;\n  let h32;\n  let t29;\n  let ul3;\n  return {\n    c() {\n      h30 = element(\"h3\");\n      h30.textContent = \"Requirements\";\n      t1 = space();\n      h40 = element(\"h4\");\n      h40.textContent = \"Event Infrastructure:\";\n      t3 = space();\n      ul0 = element(\"ul\");\n      ul0.innerHTML = `<li><b>Server:</b> A DigitalOcean server to host the Docker-based CTF challenges and scoreboard.</li> <li><b>Configuration:</b> Minimum 4 vCPU, 8GB RAM, and SSD storage.</li> <li><b>Docker:</b> All challenges will be containerized using Docker for security and portability.</li>`;\n      t12 = space();\n      h41 = element(\"h4\");\n      h41.textContent = \"Participation Requirements:\";\n      t14 = space();\n      ul1 = element(\"ul\");\n      ul1.innerHTML = `<li>Participants may register individually or in teams of up to 2 members.</li>`;\n      t16 = space();\n      h31 = element(\"h3\");\n      h31.textContent = \"Duration\";\n      t18 = space();\n      ul2 = element(\"ul\");\n      ul2.innerHTML = `<li><b>Event Length:</b> 6 hours</li> <li><b>Date:</b> 12th of January</li> <li><b>Time:</b> 3 PM to 9 PM</li>`;\n      t27 = space();\n      h32 = element(\"h3\");\n      h32.textContent = \"Prize Money\";\n      t29 = space();\n      ul3 = element(\"ul\");\n      ul3.innerHTML = `<li><b>1st Prize:</b> 10k</li> <li><b>2nd Prize:</b> 6k</li> <li><b>3rd Prize:</b> 4k</li>`;\n    },\n    m(target, anchor) {\n      insert(target, h30, anchor);\n      insert(target, t1, anchor);\n      insert(target, h40, anchor);\n      insert(target, t3, anchor);\n      insert(target, ul0, anchor);\n      insert(target, t12, anchor);\n      insert(target, h41, anchor);\n      insert(target, t14, anchor);\n      insert(target, ul1, anchor);\n      insert(target, t16, anchor);\n      insert(target, h31, anchor);\n      insert(target, t18, anchor);\n      insert(target, ul2, anchor);\n      insert(target, t27, anchor);\n      insert(target, h32, anchor);\n      insert(target, t29, anchor);\n      insert(target, ul3, anchor);\n    },\n    p: noop,\n    d(detaching) {\n      if (detaching) {\n        detach(h30);\n        detach(t1);\n        detach(h40);\n        detach(t3);\n        detach(ul0);\n        detach(t12);\n        detach(h41);\n        detach(t14);\n        detach(ul1);\n        detach(t16);\n        detach(h31);\n        detach(t18);\n        detach(ul2);\n        detach(t27);\n        detach(h32);\n        detach(t29);\n        detach(ul3);\n      }\n    }\n  };\n}\nfunction create_default_slot_1(ctx) {\n  let person0;\n  let t;\n  let person1;\n  let current;\n  person0 = new Person_default({\n    props: {\n      name: \"Kshitij Mahendra Ghodake\",\n      phone: \"123\"\n    }\n  });\n  person1 = new Person_default({\n    props: { name: \"Yazeed Nassar\", phone: \"12345\" }\n  });\n  return {\n    c() {\n      create_component(person0.$$.fragment);\n      t = space();\n      create_component(person1.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(person0, target, anchor);\n      insert(target, t, anchor);\n      mount_component(person1, target, anchor);\n      current = true;\n    },\n    p: noop,\n    i(local) {\n      if (current) return;\n      transition_in(person0.$$.fragment, local);\n      transition_in(person1.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(person0.$$.fragment, local);\n      transition_out(person1.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t);\n      }\n      destroy_component(person0, detaching);\n      destroy_component(person1, detaching);\n    }\n  };\n}\nfunction create_default_slot(ctx) {\n  let h1;\n  let t1;\n  let flexsection;\n  let current;\n  flexsection = new FlexSection_default({\n    props: {\n      $$slots: { default: [create_default_slot_1] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      h1 = element(\"h1\");\n      h1.textContent = \"Organizer\";\n      t1 = space();\n      create_component(flexsection.$$.fragment);\n    },\n    m(target, anchor) {\n      insert(target, h1, anchor);\n      insert(target, t1, anchor);\n      mount_component(flexsection, target, anchor);\n      current = true;\n    },\n    p(ctx2, dirty) {\n      const flexsection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        flexsection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      flexsection.$set(flexsection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(flexsection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(flexsection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(h1);\n        detach(t1);\n      }\n      destroy_component(flexsection, detaching);\n    }\n  };\n}\nfunction create_fragment7(ctx) {\n  let box;\n  let t0;\n  let section0;\n  let t1;\n  let section1;\n  let t2;\n  let centersection;\n  let current;\n  box = new Box_default({\n    props: {\n      $$slots: { default: [create_default_slot_4] },\n      $$scope: { ctx }\n    }\n  });\n  section0 = new Section_default({\n    props: {\n      name: \"rules\",\n      $$slots: { default: [create_default_slot_3] },\n      $$scope: { ctx }\n    }\n  });\n  section1 = new Section_default({\n    props: {\n      name: \"structure\",\n      $$slots: { default: [create_default_slot_2] },\n      $$scope: { ctx }\n    }\n  });\n  centersection = new CenterSection_default({\n    props: {\n      $$slots: { default: [create_default_slot] },\n      $$scope: { ctx }\n    }\n  });\n  return {\n    c() {\n      create_component(box.$$.fragment);\n      t0 = space();\n      create_component(section0.$$.fragment);\n      t1 = space();\n      create_component(section1.$$.fragment);\n      t2 = space();\n      create_component(centersection.$$.fragment);\n    },\n    m(target, anchor) {\n      mount_component(box, target, anchor);\n      insert(target, t0, anchor);\n      mount_component(section0, target, anchor);\n      insert(target, t1, anchor);\n      mount_component(section1, target, anchor);\n      insert(target, t2, anchor);\n      mount_component(centersection, target, anchor);\n      current = true;\n    },\n    p(ctx2, [dirty]) {\n      const box_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        box_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      box.$set(box_changes);\n      const section0_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section0_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section0.$set(section0_changes);\n      const section1_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        section1_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      section1.$set(section1_changes);\n      const centersection_changes = {};\n      if (dirty & /*$$scope*/\n      1) {\n        centersection_changes.$$scope = { dirty, ctx: ctx2 };\n      }\n      centersection.$set(centersection_changes);\n    },\n    i(local) {\n      if (current) return;\n      transition_in(box.$$.fragment, local);\n      transition_in(section0.$$.fragment, local);\n      transition_in(section1.$$.fragment, local);\n      transition_in(centersection.$$.fragment, local);\n      current = true;\n    },\n    o(local) {\n      transition_out(box.$$.fragment, local);\n      transition_out(section0.$$.fragment, local);\n      transition_out(section1.$$.fragment, local);\n      transition_out(centersection.$$.fragment, local);\n      current = false;\n    },\n    d(detaching) {\n      if (detaching) {\n        detach(t0);\n        detach(t1);\n        detach(t2);\n      }\n      destroy_component(box, detaching);\n      destroy_component(section0, detaching);\n      destroy_component(section1, detaching);\n      destroy_component(centersection, detaching);\n    }\n  };\n}\nvar Component7 = class extends SvelteComponent {\n  constructor(options) {\n    super();\n    init(this, options, null, create_fragment7, safe_not_equal, {});\n  }\n};\nvar markdown_default = Component7;\nexport {\n  markdown_default as default\n};\n",
    "isError": false
  }
}